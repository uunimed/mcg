// ==================== FIREBASE INITIALIZATION ====================
let database = null;
let firebaseInitialized = false;

try {
  const firebaseConfig = {
    apiKey: "AIzaSyAOyV8LZWBkU5W8UbTF082l1ft1T2Rj1Yc",
    authDomain: "rezidentura-7bfd5.firebaseapp.com",
    databaseURL: "https://rezidentura-7bfd5-default-rtdb.firebaseio.com",
    projectId: "rezidentura-7bfd5",
    storageBucket: "rezidentura-7bfd5.firebasestorage.app",
    messagingSenderId: "1005787481414",
    appId: "1:1005787481414:web:7c5a31471a3d1c1a159147",
    measurementId: "G-VPECPS9CEP"
  };

  if (typeof firebase !== 'undefined') {
    if (!firebase.apps.length) {
      firebase.initializeApp(firebaseConfig);
    }
    database = firebase.database();
    firebaseInitialized = true;
    console.log("Firebase initialized successfully");
  }
} catch (error) {
  console.warn("Firebase initialization failed, chat will work in local mode:", error);
}

// ==================== ENHANCED USER MANAGEMENT ====================
let currentUser = null;
let currentTestType = null;
let userProgress = {
  rezidentura: {
    normal: {},
    exam: {},
    wrongQuestions: []
  }
};

// ==================== GLOBAL VARIABLES ====================
let allTests = [];
let sessionTests = [];
let currentIndex = 0;
let autoMode = false;
let examMode = false;
let examTimeRemaining = 3 * 60 * 60;
let examTimerInterval = null;
let isEditingQuestionNumber = false;
let allTestsWithTopics = [];
let availableTopics = new Set();
let selectedTopic = null;
let lastTimerUpdate = Date.now();
let isWrongQuestionsMode = false;

// ==================== CHAT FUNCTIONS ====================
let chatMessages = [];
let onlineUsers = 1;
let userName = localStorage.getItem('chatUserName') || ('სტუმარი N' + Math.floor(Math.random() * 1000));
let userId = localStorage.getItem('chatUserId');
let isOnline = false;
let displayedMessageKeys = new Set();
let unreadMessagesCount = 0;
let isChatOpen = false;
let lastSeenMessageTime = parseInt(localStorage.getItem('lastSeenMessageTime')) || Date.now();
let allMessagesLoaded = false;

if (!userId) {  
  userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  localStorage.setItem('chatUserId', userId);
}

if (!localStorage.getItem('chatUserName')) {
  localStorage.setItem('chatUserName', userName);
}

// ==================== DOM ELEMENTS ====================
const optionsScreen = document.getElementById('optionsScreen');
const testScreen = document.getElementById('testScreen');
const questionText = document.getElementById('questionText');
const answersContainer = document.getElementById('answersContainer');
const feedback = document.getElementById('feedback');
const startBtn = document.getElementById('startBtn');
const timerElement = document.getElementById('timer');
const examRightPanel = document.getElementById('examRightPanel');
const examCountdown = document.getElementById('examCountdown');
const examTestBoxes = document.getElementById('examTestBoxes');
const questionCounter = document.getElementById('questionCounter');
const currentQuestionEl = document.getElementById('currentQuestion');
const totalQuestionsEl = document.getElementById('totalQuestions');
const loaderOverlay = document.getElementById('loaderOverlay');

// Chat elements - will be assigned in DOMContentLoaded
let chatButton, chatWindow, closeChat, chatMessagesEl, onlineCount, chatInput, sendBtn;

const modeSequential = document.getElementById('modeSequential');
const modeShuffleQuestions = document.getElementById('modeShuffleQuestions');
const modeShuffleAnswers = document.getElementById('modeShuffleAnswers');
const modeExam = document.getElementById('modeExam');

const normalModeContainer = document.getElementById('normalModeContainer');
const examModeContainer = document.getElementById('examModeContainer');
const examQuestionText = document.getElementById('examQuestionText');
const examAnswersContainer = document.getElementById('examAnswersContainer');
const examFeedback = document.getElementById('examFeedback');

// Navigation button declarations
let prevBtn, nextBtn, autoBtn;
let examPrevBtn, examNextBtn, examAutoBtn, examFinishBtn;
let detailedResultsModal = document.getElementById('detailedResultsModal');
let detailedResultsContent = document.getElementById('detailedResultsContent');

// ==================== USER PROGRESS FUNCTIONS ====================
function saveUserProgress() {
  if (currentUser && currentUser.username && currentTestType && !currentUser.isGuest) {
    try {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username]) {
        users[currentUser.username].progress = userProgress;
        localStorage.setItem('users', JSON.stringify(users));
        console.log('Progress saved for', currentUser.username);
      }
    } catch (error) {
      console.error('Error saving user progress:', error);
    }
  }
}

function loadUserProgress() {
  if (currentUser && currentUser.username) {
    try {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username] && users[currentUser.username].progress) {
        userProgress = users[currentUser.username].progress;
        console.log('Progress loaded for', currentUser.username);
      }
    } catch (error) {
      console.error('Error loading user progress:', error);
    }
  }
}

// ==================== FIXED: MISTAKE TRACKING - CORRECTLY MANAGES WRONG QUESTIONS ====================
function updateUserProgress(questionId, selectedAnswer, isCorrect, isExamMode = false) {
  if (!currentUser || currentUser.isGuest || !currentTestType) return;
  
  const mode = isExamMode ? 'exam' : 'normal';
  
  // Initialize user progress structure if needed
  if (!userProgress[currentTestType]) {
    userProgress[currentTestType] = {
      normal: { answeredQuestions: {}, currentIndex: 0 },
      exam: { answeredQuestions: {}, currentIndex: 0 },
      wrongQuestions: []
    };
  }
  
  if (!userProgress[currentTestType][mode]) {
    userProgress[currentTestType][mode] = { answeredQuestions: {}, currentIndex: 0 };
  }
  
  if (!userProgress[currentTestType].wrongQuestions) {
    userProgress[currentTestType].wrongQuestions = [];
  }
  
  // Save the answer
  userProgress[currentTestType][mode].answeredQuestions[questionId] = {
    selectedAnswer: selectedAnswer,
    isCorrect: isCorrect,
    timestamp: Date.now()
  };
  
  // FIXED: Properly manage wrongQuestions array
  const wrongQuestions = userProgress[currentTestType].wrongQuestions;
  const questionIndex = wrongQuestions.indexOf(questionId);
  
  if (!isCorrect) {
    // If answer is incorrect and question is not already in wrongQuestions, add it
    if (questionIndex === -1) {
      wrongQuestions.push(questionId);
    }
    // If it's already there, leave it (don't add duplicate)
  } else {
    // If answer is correct, remove it from wrongQuestions if it exists
    if (questionIndex !== -1) {
      wrongQuestions.splice(questionIndex, 1);
    }
  }
  
  saveUserProgress();
  
  // FIXED: Check if this was the last wrong question immediately
  setTimeout(() => {
    // Check if we're in wrong questions mode and all wrong questions are gone
    if (sessionTests.length > 0 && getWrongQuestions().length === 0) {
      showWrongQuestionsExhaustedModal();
    }
  }, 100);
}

// ==================== FIXED: CHECK IF WRONG QUESTIONS ARE EXHAUSTED ====================
function checkWrongQuestionsExhausted() {
  if (!currentUser || currentUser.isGuest || !currentTestType) return false;
  
  // მხოლოდ მაშინ შევამოწმოთ, თუ რეალურად ვართ შეცდომების რეჟიმში
  if (!isWrongQuestionsMode) return false;
  
  const wrongQuestions = getWrongQuestions();
  
  // If there are no wrong questions left, show the modal
  if (wrongQuestions.length === 0) {
    showWrongQuestionsExhaustedModal();
    return true;
  }
  
  return false;
}

// ==================== SIMPLIFIED: DIRECT RETURN TO MAIN PAGE ====================
function showWrongQuestionsExhaustedModal() {
  console.log("showWrongQuestionsExhaustedModal called!"); // Debug log
  
  // Show notification
  showNotification('კითხვები ამოიწურა. ბრუნდებით მთავარ გვერდზე!', false);
  
  // Directly return to main page after a short delay
  setTimeout(() => {
    returnToMainPage();
  }, 1500);
}

function returnToMainPage() {
  console.log("Returning to main page..."); // Debug log
  
  // Reset all test-related variables
  sessionTests = [];
  currentIndex = 0;
  autoMode = false;
  examMode = false;
  isWrongQuestionsMode = false; // გადატვირთეთ რეჟიმი
  
  // Hide test screen and show options screen
  testScreen.classList.remove('active');
  optionsScreen.style.display = 'block';
  
  // Hide all mode containers
  normalModeContainer.classList.add('hidden');
  examModeContainer.classList.add('hidden');
  examRightPanel.classList.add('hidden');
  questionCounter.classList.add('hidden');
  
  // Show timer
  timerElement.classList.remove('hidden');
  
  // Reset timer display
  updateTimerDisplay();
  
  // Show notification
  showNotification('აირჩიეთ მოდული', false);
}

function getWrongQuestions() {
  if (!currentUser || currentUser.isGuest || !currentTestType) return [];
  return userProgress[currentTestType]?.wrongQuestions || [];
}

// ==================== FIXED: WRONG QUESTIONS MODE ====================
function startWrongQuestionsMode() {
  if (!currentUser || currentUser.isGuest) {
    showNotification('მხოლოდ რეგისტრირებულ მომხმარებლებს შეუძლიათ შეცდომების გაკეთება');
    return;
  }
  
  const wrongQuestions = getWrongQuestions();
  if (wrongQuestions.length === 0) {
    showNotification('შეცდომები ვერ მოიძებნა!', false);
    return;
  }
  
  const wrongTests = allTestsWithTopics.filter((test, index) => 
    wrongQuestions.includes(index.toString())
  );
  
  if (wrongTests.length === 0) {
    showNotification('შეცდომები ვერ მოიძებნა!');
    return;
  }
  
  // მონიშნეთ, რომ ვართ შეცდომების რეჟიმში
  isWrongQuestionsMode = true;
  
  // FIXED: Store original IDs to maintain correct tracking
  sessionTests = wrongTests.map((t, idx) => ({ 
    id: wrongQuestions[idx], // Use the original question ID, not the index
    originalId: wrongQuestions[idx],
    question: t.question, 
    answers: t.answers.map(a => ({...a})),
    selectedAnswers: [],
    hasCorrectAnswer: false,
    isAnswerCorrect: null
  }));
  
  currentIndex = 0;
  examMode = false;
  
  optionsScreen.style.display = 'none';
  testScreen.classList.add('active');
  normalModeContainer.classList.remove('hidden');
  examModeContainer.classList.add('hidden');
  examRightPanel.classList.add('hidden');
  
  questionCounter.classList.remove('hidden');
  currentQuestionEl.textContent = currentIndex + 1;
  totalQuestionsEl.textContent = sessionTests.length;
  
  timerElement.classList.remove('hidden');
  
  showNotification(`შეცდომების რეჟიმი. სულ: ${wrongTests.length} ტესტი`, false);
  
  renderCurrentQuestion();
}

// ==================== AUTH FUNCTIONS ====================
function initAuth() {
  document.getElementById('authModal').style.display = 'flex';
  
  document.querySelectorAll('.auth-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      const tabName = tab.dataset.tab;
      
      document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      
      document.querySelectorAll('.auth-tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + 'Tab').classList.add('active');
    });
  });
  
  document.querySelectorAll('.password-toggle').forEach(btn => {
    btn.addEventListener('click', function() {
      const targetId = this.getAttribute('data-target');
      const input = document.getElementById(targetId);
      if (input.type === 'password') {
        input.type = 'text';
        this.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <line x1="1" y1="1" x2="23" y2="23" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`;
      } else {
        input.type = 'password';
        this.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M1 12C1 12 5 4 12 4C19 4 23 12 23 12C23 12 19 20 12 20C5 20 1 12 1 12Z" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <circle cx="12" cy="12" r="3" stroke="#64748b" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>`;
      }
    });
  });
  
  document.getElementById('continueAsGuest').addEventListener('click', () => {
    currentUser = { 
      username: 'სტუმარი ' + Math.floor(Math.random() * 1000), 
      isGuest: true,
      progress: {}
    };
    
    document.getElementById('authModal').style.display = 'none';
    document.getElementById('userInfo').style.display = 'flex';
    document.getElementById('usernameDisplay').textContent = currentUser.username;
    
    userName = currentUser.username;
    localStorage.setItem('chatUserName', userName);
    
    loadCSV();
    initChat();
    updateTimerDisplay();
    
    showNotification('მოგესალმებით!', false);
  });
  
  document.getElementById('showLoginFromGuest').addEventListener('click', () => {
    document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.auth-tab-content').forEach(c => c.classList.remove('active'));
    
    const loginTab = document.querySelector('[data-tab="login"]');
    if (loginTab) {
      loginTab.classList.add('active');
      document.getElementById('loginTab').classList.add('active');
    }
  });
  
  document.getElementById('loginBtn').addEventListener('click', handleLogin);
  document.getElementById('signupBtn').addEventListener('click', handleSignup);
  
  document.getElementById('showSignupFromLogin').addEventListener('click', (e) => {
    e.preventDefault();
    document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.auth-tab-content').forEach(c => c.classList.remove('active'));
    
    const signupTab = document.querySelector('[data-tab="signup"]');
    if (signupTab) {
      signupTab.classList.add('active');
      document.getElementById('signupTab').classList.add('active');
    }
  });
  
  document.getElementById('showLoginFromSignup').addEventListener('click', (e) => {
    e.preventDefault();
    document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.auth-tab-content').forEach(c => c.classList.remove('active'));
    
    const loginTab = document.querySelector('[data-tab="login"]');
    if (loginTab) {
      loginTab.classList.add('active');
      document.getElementById('loginTab').classList.add('active');
    }
  });
}

// ==================== FIXED: HANDLE LOGIN WITH IMMEDIATE PROGRESS CHECK ====================
function handleLogin() {
  const username = document.getElementById('loginUsername').value.trim();
  const password = document.getElementById('loginPassword').value;
  
  document.getElementById('loginUsernameError').style.display = 'none';
  document.getElementById('loginPasswordError').style.display = 'none';
  
  if (!username) {
    document.getElementById('loginUsernameError').textContent = 'მომხმარებლის სახელი აუცილებელია';
    document.getElementById('loginUsernameError').style.display = 'block';
    return;
  }
  
  if (!password) {
    document.getElementById('loginPasswordError').textContent = 'პაროლი აუცილებელია';
    document.getElementById('loginPasswordError').style.display = 'block';
    return;
  }
  
  try {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    
    if (!users[username]) {
      document.getElementById('loginUsernameError').textContent = 'ასეთი მომხმარებელი არ არსებობს';
      document.getElementById('loginUsernameError').style.display = 'block';
      return;
    }
    
    if (users[username].password !== password) {
      document.getElementById('loginPasswordError').textContent = 'პაროლი არასწორია';
      document.getElementById('loginPasswordError').style.display = 'block';
      return;
    }
    
    currentUser = { 
      username: username, 
      isGuest: false
    };
    
    loadUserProgress();
    
    document.getElementById('loginUsername').value = '';
    document.getElementById('loginPassword').value = '';
    
    document.getElementById('authModal').style.display = 'none';
    document.getElementById('userInfo').style.display = 'flex';
    document.getElementById('usernameDisplay').textContent = currentUser.username;
    
    userName = currentUser.username;
    localStorage.setItem('chatUserName', userName);
    
    showNotification('მოგესალმებით!', false);
    
    // FIXED: Check for existing progress IMMEDIATELY, before CSV loads
    // We'll store a flag that progress was checked
    const hasProgress = userProgress.rezidentura && 
                       (Object.keys(userProgress.rezidentura.normal?.answeredQuestions || {}).length > 0 ||
                        Object.keys(userProgress.rezidentura.exam?.answeredQuestions || {}).length > 0);
    
    if (hasProgress) {
      // Store progress to show modal after CSV loads
      window.pendingProgressCheck = true;
    }
    
    if (allTests.length === 0) {
      loadCSV();
    } else {
      startBtn.disabled = false;
      // Check progress now since CSV is already loaded
      setTimeout(() => {
        checkExistingProgress();
      }, 500);
    }

    initChat();
    bindUserMenuEvents();
    updateTimerDisplay();
    
  } catch (error) {
    console.error('Login error:', error);
    showNotification('შეცდომა შესვლის დროს. სცადეთ მოგვიანებით');
  }
}

function handleSignup() {
  const username = document.getElementById('signupUsername').value.trim();
  const password = document.getElementById('signupPassword').value;
  const confirmPassword = document.getElementById('signupConfirmPassword').value;
  
  document.getElementById('signupUsernameError').style.display = 'none';
  document.getElementById('signupPasswordError').style.display = 'none';
  document.getElementById('signupConfirmError').style.display = 'none';
  
  if (!username) {
    document.getElementById('signupUsernameError').textContent = 'მომხმარებლის სახელი აუცილებელია';
    document.getElementById('signupUsernameError').style.display = 'block';
    return;
  }
  
  if (username.length < 3) {
    document.getElementById('signupUsernameError').textContent = 'აუცილებელია მინიმუმ 3 სიმბოლო';
    document.getElementById('signupUsernameError').style.display = 'block';
    return;
  }
  
  if (/[^a-zA-Z0-9ა-ჰ_]/.test(username)) {
    document.getElementById('signupUsernameError').textContent = 'მომხმარებლის სახელი უნდა შეიცავდეს მხოლოდ ასოებს, ციფრებს და ქართულ ასოებს';
    document.getElementById('signupUsernameError').style.display = 'block';
    return;
  }
  
  if (!password) {
    document.getElementById('signupPasswordError').textContent = 'პაროლი აუცილებელია';
    document.getElementById('signupPasswordError').style.display = 'block';
    return;
  }
  
  if (password.length < 6) {
    document.getElementById('signupPasswordError').textContent = 'პაროლი უნდა იყოს მინიმუმ 6 სიმბოლო';
    document.getElementById('signupPasswordError').style.display = 'block';
    return;
  }
  
  if (!confirmPassword) {
    document.getElementById('signupConfirmError').textContent = 'გაიმეორეთ პაროლი!';
    document.getElementById('signupConfirmError').style.display = 'block';
    return;
  }
  
  if (password !== confirmPassword) {
    document.getElementById('signupConfirmError').textContent = 'პაროლი არ ემთხვევა';
    document.getElementById('signupConfirmError').style.display = 'block';
    return;
  }
  
  try {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    
    if (users[username]) {
      document.getElementById('signupUsernameError').textContent = 'მსგავსი მომხმარებელი უკვე არსებობს';
      document.getElementById('signupUsernameError').style.display = 'block';
      return;
    }
    
    users[username] = {
      password: password,
      progress: {
        rezidentura: {
          normal: { answeredQuestions: {}, currentIndex: 0 },
          exam: { answeredQuestions: {}, currentIndex: 0 },
          wrongQuestions: []
        }
      }
    };
    
    localStorage.setItem('users', JSON.stringify(users));
    
    document.getElementById('signupUsername').value = '';
    document.getElementById('signupPassword').value = '';
    document.getElementById('signupConfirmPassword').value = '';
    
    showNotification('რეგისტრაცია წარმატებულია!', false);
    
    setTimeout(() => {
      document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.auth-tab-content').forEach(c => c.classList.remove('active'));
      
      const loginTab = document.querySelector('[data-tab="login"]');
      if (loginTab) {
        loginTab.classList.add('active');
        document.getElementById('loginTab').classList.add('active');
      }
      
      document.getElementById('loginUsername').value = username;
      document.getElementById('loginPassword').focus();
    }, 1000);
    
  } catch (error) {
    console.error('Signup error:', error);
    showNotification('შეცდომა რეგისტრაციის დროს. სცადეთ მოგვიანებით');
  }
}

// ==================== FIXED: SHOW PASSWORD MODAL WITH FIELD-SPECIFIC ERRORS ====================
function showPasswordChangeModal() {
  // წავშალოთ არსებული მოდალი თუ არსებობს
  const existingModal = document.querySelector('.modal-overlay');
  if (existingModal) {
    existingModal.remove();
  }
  
  const modalOverlay = document.createElement('div');
  modalOverlay.className = 'modal-overlay active';
  modalOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10001;';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.cssText = 'background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);';
  
  // Modal Header
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.style.cssText = 'font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;';
  header.textContent = 'პაროლის შეცვლა';
  
  // Modal Content
  const content = document.createElement('div');
  content.className = 'modal-content';
  content.style.cssText = 'margin-bottom: 20px;';
  
  // Current Password Field with its own error
  const currentPassDiv = document.createElement('div');
  currentPassDiv.style.marginBottom = '20px';
  
  const currentPassInput = document.createElement('input');
  currentPassInput.type = 'password';
  currentPassInput.id = 'currentPassword';
  currentPassInput.placeholder = 'მიმდინარე პაროლი';
  currentPassInput.className = 'auth-input';
  currentPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const currentPassError = document.createElement('div');
  currentPassError.id = 'currentPasswordError';
  currentPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  currentPassDiv.appendChild(currentPassInput);
  currentPassDiv.appendChild(currentPassError);
  
  // New Password Field with its own error
  const newPassDiv = document.createElement('div');
  newPassDiv.style.marginBottom = '20px';
  
  const newPassInput = document.createElement('input');
  newPassInput.type = 'password';
  newPassInput.id = 'newPassword';
  newPassInput.placeholder = 'ახალი პაროლი (მინიმუმ 6 სიმბოლო)';
  newPassInput.className = 'auth-input';
  newPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const newPassError = document.createElement('div');
  newPassError.id = 'newPasswordError';
  newPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  newPassDiv.appendChild(newPassInput);
  newPassDiv.appendChild(newPassError);
  
  // Confirm Password Field with its own error
  const confirmPassDiv = document.createElement('div');
  confirmPassDiv.style.marginBottom = '20px';
  
  const confirmPassInput = document.createElement('input');
  confirmPassInput.type = 'password';
  confirmPassInput.id = 'confirmNewPassword';
  confirmPassInput.placeholder = 'გაიმეორეთ ახალი პაროლი';
  confirmPassInput.className = 'auth-input';
  confirmPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const confirmPassError = document.createElement('div');
  confirmPassError.id = 'confirmPasswordError';
  confirmPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  confirmPassDiv.appendChild(confirmPassInput);
  confirmPassDiv.appendChild(confirmPassError);
  
  // Add all fields to content
  content.appendChild(currentPassDiv);
  content.appendChild(newPassDiv);
  content.appendChild(confirmPassDiv);
  
  // Modal Buttons
  const buttons = document.createElement('div');
  buttons.className = 'modal-buttons';
  buttons.style.cssText = 'display: flex; gap: 15px; justify-content: center;';
  
  const saveBtn = document.createElement('button');
  saveBtn.id = 'savePasswordBtn';
  saveBtn.className = 'modal-btn confirm';
  saveBtn.style.cssText = 'padding: 12px 24px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;';
  saveBtn.textContent = 'განახლება';
  
  const cancelBtn = document.createElement('button');
  cancelBtn.id = 'cancelPasswordBtn';
  cancelBtn.className = 'modal-btn cancel';
  cancelBtn.style.cssText = 'padding: 12px 24px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;';
  cancelBtn.textContent = 'გაუქმება';
  
  buttons.appendChild(saveBtn);
  buttons.appendChild(cancelBtn);
  
  modal.appendChild(header);
  modal.appendChild(content);
  modal.appendChild(buttons);
  modalOverlay.appendChild(modal);
  
  document.body.appendChild(modalOverlay);
  
  // Function to hide all errors
  const hideAllErrors = () => {
    currentPassError.style.display = 'none';
    newPassError.style.display = 'none';
    confirmPassError.style.display = 'none';
  };
  
  // Add event listeners
  saveBtn.addEventListener('click', () => {
    const currentPassword = document.getElementById('currentPassword').value;
    const newPassword = document.getElementById('newPassword').value;
    const confirmPassword = document.getElementById('confirmNewPassword').value;
    
    hideAllErrors();
    
    let hasError = false;
    
    if (!currentPassword) {
      currentPassError.textContent = 'მიმდინარე პაროლი აუცილებელია';
      currentPassError.style.display = 'block';
      hasError = true;
    }
    
    if (!newPassword) {
      newPassError.textContent = 'ახალი პაროლი აუცილებელია';
      newPassError.style.display = 'block';
      hasError = true;
    } else if (newPassword.length < 6) {
      newPassError.textContent = 'ახალი პაროლი უნდა იყოს მინიმუმ 6 სიმბოლო';
      newPassError.style.display = 'block';
      hasError = true;
    }
    
    if (!confirmPassword) {
      confirmPassError.textContent = 'გთხოვთ გაიმეოროთ ახალი პაროლი';
      confirmPassError.style.display = 'block';
      hasError = true;
    } else if (newPassword && newPassword !== confirmPassword) {
      confirmPassError.textContent = 'ახალი პაროლი არ ემთხვევა';
      confirmPassError.style.display = 'block';
      hasError = true;
    }
    
    if (hasError) return;
    
    try {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username]?.password !== currentPassword) {
        currentPassError.textContent = 'მიმდინარე პაროლი არასწორია';
        currentPassError.style.display = 'block';
        return;
      }
      
      users[currentUser.username].password = newPassword;
      localStorage.setItem('users', JSON.stringify(users));
      
      // Close modal and show success
      modalOverlay.remove();
      showNotification('პაროლი წარმატებით შეიცვალა', false);
    } catch (error) {
      console.error('Error changing password:', error);
      newPassError.textContent = 'შეცდომა პაროლის შეცვლისას';
      newPassError.style.display = 'block';
    }
  });
  
  cancelBtn.addEventListener('click', () => {
    modalOverlay.remove();
  });
  
  // Close on overlay click
  modalOverlay.addEventListener('click', (e) => {
    if (e.target === modalOverlay) {
      modalOverlay.remove();
    }
  });
}

function showContinueOrRestartModal(progress) {
  // წავშალოთ არსებული მოდალი თუ არსებობს
  const existingModal = document.querySelector('.modal-overlay[data-type="continue"]');
  if (existingModal) existingModal.remove();
  
  const hasNormal = progress.normal && Object.keys(progress.normal.answeredQuestions || {}).length > 0;
  const hasExam = progress.exam && Object.keys(progress.exam.answeredQuestions || {}).length > 0;
  
  let message = '';
  if (hasNormal && hasExam) {
    message = 'თქვენ გაქვთ შენახული პროგრესი როგორც ნორმალურ, ასევე საგამოცდო რეჟიმში.';
  } else if (hasNormal) {
    message = 'თქვენ გაქვთ შენახული პროგრესი ნორმალურ რეჟიმში.';
  } else if (hasExam) {
    message = 'თქვენ გაქვთ შენახული პროგრესი საგამოცდო რეჟიმში.';
  }
  
  const modalHTML = `
    <div class="modal-overlay active" data-type="continue" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10001;">
      <div class="modal" style="background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <div class="modal-header" style="font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;">გსურთ გაგრძელება?</div>
        <div class="modal-content" style="margin-bottom: 30px;">
          <p style="margin-bottom: 15px; text-align: center;">${message}</p>
          <p style="margin-bottom: 20px; text-align: center; font-weight: 600;">როგორ გსურთ გააგრძელოთ?</p>
          <div style="margin-top: 15px; padding: 15px; background: #f8fafc; border-radius: 8px;">
            <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
              <span>ნორმალური რეჟიმი:</span>
              <span style="font-weight: 600;">${hasNormal ? Object.keys(progress.normal.answeredQuestions || {}).length + ' კითხვა' : 'არ არის დაწყებული'}</span>
            </div>
            <div style="display: flex; justify-content: space-between;">
              <span>საგამოცდო რეჟიმი:</span>
              <span style="font-weight: 600;">${hasExam ? Object.keys(progress.exam.answeredQuestions || {}).length + ' კითხვა' : 'არ არის დაწყებული'}</span>
            </div>
          </div>
        </div>
        <div class="modal-buttons" style="display: flex; gap: 15px; justify-content: center;">
          <button id="continueProgressBtn" class="modal-btn confirm" style="padding: 12px 24px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">გაგრძელება</button>
          <button id="restartProgressBtn" class="modal-btn" style="padding: 12px 24px; background: var(--accent); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">ხელახლა დაწყება</button>
          <button id="closeProgressBtn" class="modal-btn cancel" style="padding: 12px 24px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">დახურვა</button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer.firstChild);
  
  document.getElementById('continueProgressBtn').addEventListener('click', () => {
    // ავტომატურად ჩავრთოთ შესაბამისი რეჟიმი და გავაგრძელოთ
    modalContainer.remove();
    
    // თუ ორივე რეჟიმშია პროგრესი, ვკითხოთ რომელი გააგრძელოს
    if (hasNormal && hasExam) {
      chooseModeToContinue(progress);
    } else if (hasNormal) {
      startSavedProgress('normal', progress);
    } else if (hasExam) {
      startSavedProgress('exam', progress);
    }
  });
  
  document.getElementById('restartProgressBtn').addEventListener('click', () => {
    // წავშალოთ პროგრესი და დავიწყოთ თავიდან
    if (currentUser && currentUser.username) {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username] && users[currentUser.username].progress) {
        users[currentUser.username].progress = {
          rezidentura: {
            normal: { answeredQuestions: {}, currentIndex: 0 },
            exam: { answeredQuestions: {}, currentIndex: 0 },
            wrongQuestions: []
          }
        };
        localStorage.setItem('users', JSON.stringify(users));
        userProgress = users[currentUser.username].progress;
      }
    }
    modalContainer.remove();
    showNotification('პროგრესი წაიშალა. შეგიძლიათ თავიდან დაიწყოთ.', false);
  });
  
  document.getElementById('closeProgressBtn').addEventListener('click', () => {
    modalContainer.remove();
  });
}

function chooseModeToContinue(progress) {
  const modalHTML = `
    <div class="modal-overlay active" data-type="mode-select" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10002;">
      <div class="modal" style="background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <div class="modal-header" style="font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;">აირჩიეთ რეჟიმი</div>
        <div class="modal-content" style="margin-bottom: 30px;">
          <p style="margin-bottom: 20px; text-align: center;">რომელი რეჟიმის გაგრძელება გსურთ?</p>
          <div style="display: flex; gap: 15px; justify-content: center;">
            <button id="chooseNormalBtn" style="flex:1; padding: 20px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; cursor: pointer;">
              <div style="font-size: 18px; font-weight: 600; color: var(--accent); margin-bottom: 8px;">ნორმალური</div>
              <div style="font-size: 14px; color: #64748b;">${Object.keys(progress.normal.answeredQuestions || {}).length} კითხვა</div>
            </button>
            <button id="chooseExamBtn" style="flex:1; padding: 20px; background: #f8fafc; border: 2px solid #e2e8f0; border-radius: 12px; cursor: pointer;">
              <div style="font-size: 18px; font-weight: 600; color: var(--danger); margin-bottom: 8px;">საგამოცდო</div>
              <div style="font-size: 14px; color: #64748b;">${Object.keys(progress.exam.answeredQuestions || {}).length} კითხვა</div>
            </button>
          </div>
        </div>
        <div class="modal-buttons" style="display: flex; justify-content: center;">
          <button id="closeModeSelectBtn" class="modal-btn cancel" style="padding: 12px 24px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">გაუქმება</button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer.firstChild);
  
  document.getElementById('chooseNormalBtn').addEventListener('click', () => {
    startSavedProgress('normal', progress);
    modalContainer.remove();
  });
  
  document.getElementById('chooseExamBtn').addEventListener('click', () => {
    startSavedProgress('exam', progress);
    modalContainer.remove();
  });
  
  document.getElementById('closeModeSelectBtn').addEventListener('click', () => {
    modalContainer.remove();
  });
}

function startSavedProgress(mode, progress) {
  // ჩავრთოთ შესაბამისი ჩეკბოქსები
  const modeExam = document.getElementById('modeExam');
  const modeSequential = document.getElementById('modeSequential');
  const modeShuffleQuestions = document.getElementById('modeShuffleQuestions');
  const modeShuffleAnswers = document.getElementById('modeShuffleAnswers');
  
  if (mode === 'exam') {
    if (modeExam) modeExam.checked = true;
    if (modeSequential) modeSequential.checked = false;
    if (modeShuffleQuestions) modeShuffleQuestions.checked = true;
    if (modeShuffleAnswers) modeShuffleAnswers.checked = true;
  } else {
    if (modeExam) modeExam.checked = false;
    if (modeSequential) modeSequential.checked = true;
  }
  
  // ავირჩიოთ რეზიდენტურის მოდული
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (testTypeSelect) {
    testTypeSelect.value = 'rezidentura';
    currentTestType = 'rezidentura';
    toggleTopicsDropdown();
  }
  
  // ავირჩიოთ ყველა თემა
  const topicsSelect = document.getElementById('topicsSelect');
  if (topicsSelect) {
    topicsSelect.value = 'all';
    selectedTopic = null;
  }
  
  // გადავცეთ პროგრესი
  window.savedProgress = progress;
  
  // დავიწყოთ ტესტი
  setTimeout(() => {
    if (allTestsWithTopics.length > 0) {
      startTest();
    } else {
      loadCSV();
    }
  }, 300);
}

// ==================== CHAT FUNCTIONS ====================
function initChat() {
  console.log("Initializing chat...");
  
  if (!chatMessagesEl || !chatButton || !chatWindow) {
    console.error("Chat elements not initialized yet");
    return;
  }
  
  chatMessagesEl.innerHTML = '';
  onlineCount.textContent = '1';
  
  if (currentUser && currentUser.username) {
    userName = currentUser.username;
    localStorage.setItem('chatUserName', userName);
  }
  
  // აღვადგინოთ unreadMessagesCount 0-ზე, რადგან ახლა ვტვირთავთ გვერდს
  unreadMessagesCount = 0;
  updateChatNotification();
  
  if (firebaseInitialized && database) {
    console.log("Setting up Firebase chat...");
    setupFirebaseListeners();
  } else {
    console.log("Using local chat mode");
    loadLocalMessagesAsFallback();
  }
  
  chatButton.replaceWith(chatButton.cloneNode(true));
  closeChat.replaceWith(closeChat.cloneNode(true));
  sendBtn.replaceWith(sendBtn.cloneNode(true));
  
  chatButton = document.getElementById('chatButton');
  closeChat = document.querySelector('.close-chat');
  sendBtn = document.getElementById('sendBtn');
  chatInput = document.getElementById('chatInput');
  
  chatButton.addEventListener('click', () => {
    chatWindow.classList.toggle('active');
    if (chatWindow.classList.contains('active')) {
      isChatOpen = true;
      // როცა ჩატს ვხსნით, ყველა წაკითხულად ჩაითვლება
      markAllMessagesAsRead();
      chatInput.focus();
      
      setTimeout(() => {
        chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
      }, 100);
    } else {
      isChatOpen = false;
    }
  });
  
  closeChat.addEventListener('click', () => {
    chatWindow.classList.remove('active');
    isChatOpen = false;
  });
  
  sendBtn.addEventListener('click', sendMessageToFirebase);
  
  chatInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') sendMessageToFirebase();
  });
}

function markAllMessagesAsRead() {
  unreadMessagesCount = 0;
  updateChatNotification();
  // შევინახოთ მიმდინარე დრო, როგორც ბოლო ნანახი წერილის დრო
  lastSeenMessageTime = Date.now();
  localStorage.setItem('lastSeenMessageTime', lastSeenMessageTime.toString());
}

function setupFirebaseListeners() {
  try {
    displayedMessageKeys.clear();
    
    // ჯერ ჩავტვირთოთ ბოლო 50 წერილი
    database.ref('chat/messages').limitToLast(50).once('value').then((snapshot) => {
      if (snapshot.exists()) {
        const messages = [];
        
        snapshot.forEach((childSnapshot) => {
          const message = childSnapshot.val();
          const messageKey = childSnapshot.key;
          messages.push({ ...message, key: messageKey });
        });
        
        messages.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
        
        messages.forEach(msg => {
          displayedMessageKeys.add(msg.key);
          const isMyMessage = msg.userId === userId;
          
          // დავამატოთ წერილი ჩატში
          addMessageToChat(msg.author, msg.text, isMyMessage, new Date(msg.timestamp));
          
          // განვაახლოთ unreadMessagesCount - მხოლოდ იმ წერილებისთვის, რომლებიც უფრო გვიანია ვიდრე lastSeenMessageTime
          // და არ არის ჩემი საკუთარი წერილი
          if (!isMyMessage && msg.timestamp > lastSeenMessageTime) {
            unreadMessagesCount++;
          }
        });
        
        // განვაახლოთ ნოტიფიკაცია
        updateChatNotification();
        
        setTimeout(() => {
          if (isChatOpen) {
            chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
          }
        }, 200);
      }
      
      allMessagesLoaded = true;
    }).catch(error => {
      console.error('Error loading initial messages:', error);
      loadLocalMessagesAsFallback();
    });
    
    // მოვუსმინოთ ახალ წერილებს
    database.ref('chat/messages').orderByKey().limitToLast(1).on('child_added', (snapshot) => {
      const message = snapshot.val();
      const messageKey = snapshot.key;
      
      // თუ უკვე გვაქვს ეს წერილი, გამოვტოვოთ
      if (displayedMessageKeys.has(messageKey)) {
        return;
      }
      
      displayedMessageKeys.add(messageKey);
      const isMyMessage = message.userId === userId;
      
      if (!isMyMessage) {
        const messageTime = message.timestamp || Date.now();
        
        // დავამატოთ წერილი ჩატში
        addMessageToChat(message.author, message.text, false, new Date(messageTime));
        
        // თუ ჩატი არ არის გახსნილი და წერილი ახალია (უფრო გვიანი ვიდრე lastSeenMessageTime)
        if (!isChatOpen && messageTime > lastSeenMessageTime) {
          unreadMessagesCount++;
          updateChatNotification();
        }
        
        lastSeenMessageTime = Math.max(lastSeenMessageTime, messageTime);
      }
    });
    
    database.ref('chat/onlineUsers').on('value', (snapshot) => {
      if (snapshot.exists()) {
        const users = snapshot.val();
        const now = Date.now();
        let activeUsers = 1;
        
        Object.keys(users).forEach(key => {
          if (users[key]?.userId !== userId && 
              users[key]?.lastSeen && 
              (now - users[key].lastSeen) < 30000) {
            activeUsers++;
          }
        });
        
        onlineCount.textContent = activeUsers.toString();
      } else {
        onlineCount.textContent = '1';
      }
    });
    
    setUserOnline();
    
  } catch (error) {
    console.error("Firebase listener error:", error);
    loadLocalMessagesAsFallback();
  }
}

function loadLocalMessagesAsFallback() {
  console.log("Loading local messages as fallback...");
  try {
    let localMessages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
    
    localMessages.sort((a, b) => {
      const timeA = new Date(a.timestamp).getTime();
      const timeB = new Date(b.timestamp).getTime();
      return timeA - timeB;
    });
    
    if (localMessages.length > 0) {
      localMessages.forEach(msg => {
        const isSent = msg.userId === userId;
        addMessageToChat(msg.author, msg.text, isSent, new Date(msg.timestamp));
      });
    }
    addMessageToChat('სისტემა', 'კეთილი იყოს თქვენი მობრძანება! (ლოკალური რეჟიმი)', false, new Date());
  } catch (e) {
    console.error('Error loading local messages:', e);
    addMessageToChat('სისტემა', 'კეთილი იყოს თქვენი მობრძანება!', false, new Date());
  }
}

function setUserOnline() {
  if (!firebaseInitialized || !database) return;
  
  try {
    const userRef = database.ref('chat/onlineUsers/' + userId);
    
    database.ref('chat/onlineUsers').once('value').then((snapshot) => {
      if (snapshot.exists()) {
        const users = snapshot.val();
        const now = Date.now();
        const updates = {};
        
        Object.keys(users).forEach(key => {
          if (users[key]?.lastSeen && (now - users[key].lastSeen) > 60000) {
            updates[key] = null;
          }
        });
        
        if (Object.keys(updates).length > 0) {
          database.ref('chat/onlineUsers').update(updates);
        }
      }
    });
    
    userRef.set({
      name: userName,
      userId: userId,
      lastSeen: Date.now()
    });
    
    isOnline = true;
    
    setInterval(() => {
      if (isOnline && firebaseInitialized) {
        userRef.update({ lastSeen: Date.now() });
      }
    }, 10000);
    
    window.addEventListener('beforeunload', () => {
      if (firebaseInitialized) {
        userRef.remove();
      }
      isOnline = false;
    });
  } catch (error) {
    console.error("Error setting user online:", error);
  }
}

function sendMessageToFirebase() {
  if (!chatInput) return;
  
  const message = chatInput.value.trim();
  if (!message) return;
  
  if (!userName) {
    if (currentUser && currentUser.username) {
      userName = currentUser.username;
    } else {
      userName = 'სტუმარი N' + Math.floor(Math.random() * 1000);
    }
    localStorage.setItem('chatUserName', userName);
  }
  
  const messageData = {
    text: message,
    author: userName,
    userId: userId,
    timestamp: Date.now()
  };
  
  chatInput.value = '';
  
  addMessageToChat(userName, message, true, new Date());
  
  saveMessageToLocalStorage(messageData);
  
  if (firebaseInitialized && database) {
    const newMessageRef = database.ref('chat/messages').push();
    const messageKey = newMessageRef.key;
    
    displayedMessageKeys.add(messageKey);
    
    newMessageRef.set(messageData)
      .catch((error) => {
        console.error('Error sending message to Firebase:', error);
        showNotification('შეტყობინება შენახულია მხოლოდ ლოკალურად', false);
      });
  } else {
    showNotification('შეტყობინება შენახულია ლოკალურად', false);
  }
}

function saveMessageToLocalStorage(messageData) {
  try {
    let localMessages = JSON.parse(localStorage.getItem('chatMessages') || '[]');
    localMessages.push({
      ...messageData,
      timestamp: new Date().toISOString()
    });
    
    if (localMessages.length > 100) {
      localMessages = localMessages.slice(-100);
    }
    
    localStorage.setItem('chatMessages', JSON.stringify(localMessages));
  } catch (e) {
    console.error('Error saving to localStorage:', e);
  }
}

function addMessageToChat(author, message, isSent, timestamp) {
  if (!chatMessagesEl) return;
  
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
  
  const time = timestamp.toLocaleTimeString('ka-GE', {
    hour: '2-digit',
    minute: '2-digit'
  });
  
  messageDiv.innerHTML = `
    <div class="message-author">${escapeHtml(author)}</div>
    <div class="message-time">${time}</div>
    <div class="message-content">${escapeHtml(message)}</div>
  `;
  
  chatMessagesEl.appendChild(messageDiv);
  
  // განვაახლოთ lastSeenMessageTime, თუ წერილი ჩემია
  if (isSent) {
    lastSeenMessageTime = Math.max(lastSeenMessageTime, timestamp.getTime());
    localStorage.setItem('lastSeenMessageTime', lastSeenMessageTime.toString());
  }
  
  if (isChatOpen) {
    setTimeout(() => {
      chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
    }, 100);
  }
}

function updateChatNotification() {
  const notification = document.getElementById('chatNotification');
  if (notification) {
    if (unreadMessagesCount > 0) {
      notification.style.display = 'flex';
      if (unreadMessagesCount > 99) {
        notification.textContent = '99+';
        notification.setAttribute('data-count', 'many');
      } else {
        notification.textContent = unreadMessagesCount.toString();
        notification.removeAttribute('data-count');
      }
    } else {
      notification.style.display = 'none';
    }
  }
}

// ==================== TOPIC FUNCTIONS ====================
function toggleTopicsDropdown() {
  const testTypeSelect = document.getElementById('testTypeSelect');
  const topicsContainer = document.getElementById('topicsDropdownContainer');
  
  if (!testTypeSelect || !topicsContainer) return;
  
  if (testTypeSelect.value === 'rezidentura') {
    topicsContainer.style.display = 'flex';
  } else {
    topicsContainer.style.display = 'none';
    const topicsSelect = document.getElementById('topicsSelect');
    if (topicsSelect) topicsSelect.value = 'all';
    selectedTopic = null;
  }
}

function bindTestTypeEvents() {
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (testTypeSelect) {
    testTypeSelect.addEventListener('change', function() {
      toggleTopicsDropdown();
      const startBtn = document.getElementById('startBtn');
      if (startBtn) {
        startBtn.disabled = !this.value;
      }
      // ჩატვირთეთ ახალი ტესტები ტიპის შეცვლისას
      if (this.value && allTests.length > 0) {
        loadCSV();
      }
    });
  }
}

// ==================== UTILITY FUNCTIONS ====================
function escapeHtml(s){ 
  if(!s) return ''; 
  return String(s).replace(/[&<>"']/g, m => ({
    '&':'&amp;',
    '<':'&lt;',
    '>':'&gt;',
    '"':'&quot;',
    "'":'&#039;'
  }[m])); 
}

function shuffleArray(a){ 
  for(let i=a.length-1;i>0;i--){ 
    const j=Math.floor(Math.random()*(i+1)); 
    [a[i],a[j]]=[a[j],a[i]]; 
  } 
}

function showNotification(message, isError = true) {
  const existing = document.querySelector('.notification');
  if (existing) existing.remove();
  
  const notification = document.createElement('div');
  notification.className = 'notification';
  notification.textContent = message;
  notification.style.background = isError ? 'var(--danger)' : 'var(--success)';
  
  document.body.appendChild(notification);
  
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 4000);
}

function resetLoader() {
  loaderOverlay.innerHTML = `
    <div class="spinner"></div>
    <div class="loader-text">იტვირთება...</div>
  `;
}

function updateTimerDisplay() {
  const now = new Date();
  const timeStr = now.toLocaleTimeString('ka-GE');
  
  timerElement.innerHTML = `
    <span class="timer-separator">|</span>
    <span class="timer-time">${timeStr}</span>
  `;
}

function updateTimer() {
  updateTimerDisplay();
  if (examMode) {
    updateExamTimer();
  }
}

function updateExamTimer() {
  if (!examMode) return;
  
  // Calculate actual elapsed time
  const now = Date.now();
  const elapsed = Math.floor((now - lastTimerUpdate) / 1000);
  
  if (elapsed > 0) {
    examTimeRemaining = Math.max(0, examTimeRemaining - elapsed);
    lastTimerUpdate = now;
  }
  
  const hours = Math.floor(examTimeRemaining / 3600);
  const minutes = Math.floor((examTimeRemaining % 3600) / 60);
  const seconds = examTimeRemaining % 60;
  
  examCountdown.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  
  if (examTimeRemaining <= 0) {
    clearInterval(examTimerInterval);
    examTimerInterval = null;
    completeExam();
  }
}

// ==================== EXAM MODE FUNCTIONS ====================
function createExamTestBoxes() {
  if (!examTestBoxes) return;
  
  examTestBoxes.innerHTML = '';
  
  for (let i = 0; i < sessionTests.length; i++) {
    const testBox = document.createElement('div');
    testBox.className = 'test-box';
    testBox.textContent = i + 1;
    testBox.dataset.index = i;
    
    if (i === currentIndex) {
      testBox.classList.add('current');
    }
    
    if (sessionTests[i] && sessionTests[i].selectedAnswers && sessionTests[i].selectedAnswers.length > 0) {
      testBox.classList.add('answered');
    }
    
    testBox.addEventListener('click', () => {
      currentIndex = i;
      renderCurrentQuestion();
    });
    
    examTestBoxes.appendChild(testBox);
  }
}

function startExamMode() {
  examMode = true;
  
  // Reset timer when starting new exam
  if (!window.savedProgress || !window.savedProgress.exam?.examTimeRemaining) {
    examTimeRemaining = 3 * 60 * 60;
  }
  
  lastTimerUpdate = Date.now();
  
  timerElement.classList.add('hidden');
  normalModeContainer.classList.add('hidden');
  examModeContainer.classList.remove('hidden');
  examRightPanel.classList.remove('hidden');
  questionCounter.classList.add('hidden');
  
  createExamTestBoxes();
  
  // Clear any existing interval
  if (examTimerInterval) {
    clearInterval(examTimerInterval);
    examTimerInterval = null;
  }
  
  // Start new interval
  examTimerInterval = setInterval(updateExamTimer, 1000);
  updateExamTimer(); // Immediate update
  
  // FIXED: Ensure finish button is visible in exam mode
  if (examFinishBtn) {
    examFinishBtn.style.display = 'flex';
  }
}

// ==================== FIXED: SETTINGS PAGE - 80% WIDTH, 90% HEIGHT, VECTOR CLOSE ====================
function showSettingsPage() {
  if (!currentUser || currentUser.isGuest) {
    showNotification('მხოლოდ რეგისტრირებულ მომხმარებლებს შეუძლიათ პარამეტრების ნახვა');
    return;
  }

  const settingsHTML = `
    <div id="settingsPage" class="settings-page">
      <div class="settings-container">
        <div class="settings-header">
          <h2>პარამეტრები</h2>
          <button class="settings-close-btn" id="vectorCloseSettings">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M18 6L6 18M6 6l12 12"/>
            </svg>
          </button>
        </div>
        
        <div id="settingsContent">
          <!-- User Info Section -->
          <div class="settings-section">
            <div class="settings-section-title">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                <path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" fill="${currentUser ? '#0ea5a4' : '#64748b'}"/>
              </svg>
              პირადი ინფორმაცია
            </div>
            
            <!-- Username Field -->
            <div class="settings-field">
              <label class="settings-label">მომხმარებელი</label>
              <div class="settings-input-group">
                <input type="text" id="settingsUsername" class="settings-input" value="${escapeHtml(currentUser?.username || '')}" disabled>
                <button class="settings-edit-btn" onclick="enableUsernameEdit()">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" stroke="currentColor" fill="currentColor"/>
                  </svg>
                  სახელის შეცვლა
                </button>
              </div>
            </div>
            
            <!-- Password Field with Eye Toggle -->
            <div class="settings-field">
              <label class="settings-label">პაროლი</label>
              <div class="settings-input-group">
                <input type="password" id="settingsPassword" class="settings-input" value="${escapeHtml(getUserPassword(currentUser?.username) || '')}" disabled>
                <button class="settings-eye-btn" onclick="togglePasswordVisibility('settingsPassword', this)">
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                    <path d="M1 12C1 12 5 4 12 4C19 4 23 12 23 12C23 12 19 20 12 20C5 20 1 12 1 12Z" stroke="currentColor" stroke-width="2"/>
                    <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
                  </svg>
                </button>
                <button class="settings-edit-btn" onclick="showPasswordChangeFromSettings()">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
                    <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" stroke="currentColor" fill="currentColor"/>
                  </svg>
                  პაროლის შეცვლა
                </button>
              </div>
            </div>
          </div>
          
          <!-- Mistakes Section -->
          <div class="settings-section">
            <div class="settings-section-title">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                <path d="M18 6L6 18M6 6l12 12" stroke="#dc2626" stroke-width="2" stroke-linecap="round"/>
              </svg>
              შეცდომების ისტორია
            </div>
            
            <div id="mistakesList" class="mistakes-container">
              ${renderMistakesList()}
            </div>
            
            <button class="settings-print-btn" onclick="printMistakes()">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                <path d="M6 9V3h12v6m0 4h.01M6 15h12v6H6v-6z" stroke="white" stroke-width="2"/>
                <path d="M6 19v-4h12v4" stroke="white" stroke-width="2"/>
              </svg>
              ბეჭდვა
            </button>
          </div>
          
          <!-- Actions -->
          <div class="settings-actions">
            <button class="settings-back-btn" onclick="closeSettingsPage()">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none">
                <path d="M15 18L9 12L15 6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
              მთავარი გვერდი
            </button>
          </div>
        </div>
      </div>
    </div>
  `;

  const existingSettings = document.getElementById('settingsPage');
  if (existingSettings) {
    existingSettings.remove();
  }

  document.body.insertAdjacentHTML('beforeend', settingsHTML);
  
  // FIXED: Vector close button event listener
  document.getElementById('vectorCloseSettings').addEventListener('click', closeSettingsPage);
}

function getUserPassword(username) {
  try {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    return users[username]?.password || '';
  } catch (error) {
    console.error('Error getting user password:', error);
    return '';
  }
}

function togglePasswordVisibility(inputId, button) {
  const input = document.getElementById(inputId);
  if (input.type === 'password') {
    input.type = 'text';
    button.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none">
      <path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24" stroke="currentColor" stroke-width="2"/>
      <line x1="1" y1="1" x2="23" y2="23" stroke="currentColor" stroke-width="2"/>
    </svg>`;
  } else {
    input.type = 'password';
    button.innerHTML = `<svg width="20" height="20" viewBox="0 0 24 24" fill="none">
      <path d="M1 12C1 12 5 4 12 4C19 4 23 12 23 12C23 12 19 20 12 20C5 20 1 12 1 12Z" stroke="currentColor" stroke-width="2"/>
      <circle cx="12" cy="12" r="3" stroke="currentColor" stroke-width="2"/>
    </svg>`;
  }
}

function enableUsernameEdit() {
  const usernameInput = document.getElementById('settingsUsername');
  if (usernameInput) {
    usernameInput.disabled = false;
    usernameInput.focus();
    
    if (!document.getElementById('saveUsernameBtn')) {
      const saveBtn = document.createElement('button');
      saveBtn.id = 'saveUsernameBtn';
      saveBtn.className = 'settings-edit-btn';
      saveBtn.style.color = 'var(--success)';
      saveBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
          <path d="M5 13l4 4L19 7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
        </svg>
        შენახვა
      `;
      saveBtn.onclick = saveUsername;
      usernameInput.parentElement.appendChild(saveBtn);
    }
  }
}

function saveUsername() {
  const newUsername = document.getElementById('settingsUsername').value.trim();
  
  if (!newUsername) {
    showNotification('მომხმარებლის სახელი არ შეიძლება იყოს ცარიელი');
    return;
  }
  
  if (newUsername === currentUser.username) {
    showNotification('ახალი სახელი ემთხვევა ძველს', false);
    cancelUsernameEdit();
    return;
  }
  
  try {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    
    if (users[newUsername]) {
      showNotification('ეს სახელი უკვე გამოყენებულია');
      return;
    }
    
    users[newUsername] = users[currentUser.username];
    delete users[currentUser.username];
    
    localStorage.setItem('users', JSON.stringify(users));
    
    const oldUsername = currentUser.username;
    currentUser.username = newUsername;
    
    document.getElementById('usernameDisplay').textContent = newUsername;
    userName = newUsername;
    localStorage.setItem('chatUserName', userName);
    
    showNotification('მომხმარებლის სახელი წარმატებით შეიცვალა', false);
    
    closeSettingsPage();
    setTimeout(() => showSettingsPage(), 300);
    
  } catch (error) {
    console.error('Error saving username:', error);
    showNotification('შეცდომა სახელის შეცვლისას');
  }
}

function cancelUsernameEdit() {
  const usernameInput = document.getElementById('settingsUsername');
  if (usernameInput) {
    usernameInput.disabled = true;
    usernameInput.value = currentUser?.username || '';
    
    const saveBtn = document.getElementById('saveUsernameBtn');
    if (saveBtn) saveBtn.remove();
  }
}

// ==================== FIXED: SHOW PASSWORD MODAL FROM SETTINGS WITH FIELD-SPECIFIC ERRORS ====================
function showPasswordChangeFromSettings() {
  console.log("Opening password change modal from settings");
  
  const modalOverlay = document.createElement('div');
  modalOverlay.className = 'modal-overlay active';
  modalOverlay.id = 'passwordModalOverlay';
  modalOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10002;';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.cssText = 'background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);';
  
  // Modal Header
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.style.cssText = 'font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;';
  header.textContent = 'პაროლის შეცვლა';
  
  // Modal Content
  const content = document.createElement('div');
  content.className = 'modal-content';
  content.style.cssText = 'margin-bottom: 20px;';
  
  // Current Password Field with its own error
  const currentPassDiv = document.createElement('div');
  currentPassDiv.style.marginBottom = '20px';
  
  const currentPassInput = document.createElement('input');
  currentPassInput.type = 'password';
  currentPassInput.id = 'currentPassword';
  currentPassInput.placeholder = 'მიმდინარე პაროლი';
  currentPassInput.className = 'auth-input';
  currentPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const currentPassError = document.createElement('div');
  currentPassError.id = 'currentPasswordError';
  currentPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  currentPassDiv.appendChild(currentPassInput);
  currentPassDiv.appendChild(currentPassError);
  
  // New Password Field with its own error
  const newPassDiv = document.createElement('div');
  newPassDiv.style.marginBottom = '20px';
  
  const newPassInput = document.createElement('input');
  newPassInput.type = 'password';
  newPassInput.id = 'newPassword';
  newPassInput.placeholder = 'ახალი პაროლი (მინიმუმ 6 სიმბოლო)';
  newPassInput.className = 'auth-input';
  newPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const newPassError = document.createElement('div');
  newPassError.id = 'newPasswordError';
  newPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  newPassDiv.appendChild(newPassInput);
  newPassDiv.appendChild(newPassError);
  
  // Confirm Password Field with its own error
  const confirmPassDiv = document.createElement('div');
  confirmPassDiv.style.marginBottom = '20px';
  
  const confirmPassInput = document.createElement('input');
  confirmPassInput.type = 'password';
  confirmPassInput.id = 'confirmNewPassword';
  confirmPassInput.placeholder = 'გაიმეორეთ ახალი პაროლი';
  confirmPassInput.className = 'auth-input';
  confirmPassInput.style.cssText = 'width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 5px;';
  
  const confirmPassError = document.createElement('div');
  confirmPassError.id = 'confirmPasswordError';
  confirmPassError.style.cssText = 'color: var(--danger); font-size: 13px; margin-top: 4px; display: none; text-align: left;';
  
  confirmPassDiv.appendChild(confirmPassInput);
  confirmPassDiv.appendChild(confirmPassError);
  
  // Add all fields to content
  content.appendChild(currentPassDiv);
  content.appendChild(newPassDiv);
  content.appendChild(confirmPassDiv);
  
  // Modal Buttons
  const buttons = document.createElement('div');
  buttons.className = 'modal-buttons';
  buttons.style.cssText = 'display: flex; gap: 15px; justify-content: center;';
  
  const saveBtn = document.createElement('button');
  saveBtn.id = 'savePasswordBtn';
  saveBtn.className = 'modal-btn confirm';
  saveBtn.style.cssText = 'padding: 12px 24px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;';
  saveBtn.textContent = 'განახლება';
  
  const cancelBtn = document.createElement('button');
  cancelBtn.id = 'cancelPasswordBtn';
  cancelBtn.className = 'modal-btn cancel';
  cancelBtn.style.cssText = 'padding: 12px 24px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;';
  cancelBtn.textContent = 'გაუქმება';
  
  buttons.appendChild(saveBtn);
  buttons.appendChild(cancelBtn);
  
  modal.appendChild(header);
  modal.appendChild(content);
  modal.appendChild(buttons);
  modalOverlay.appendChild(modal);
  
  document.body.appendChild(modalOverlay);
  
  // Function to hide all errors
  const hideAllErrors = () => {
    currentPassError.style.display = 'none';
    newPassError.style.display = 'none';
    confirmPassError.style.display = 'none';
  };
  
  // Add event listeners
  saveBtn.addEventListener('click', function() {
    const currentPassword = document.getElementById('currentPassword').value;
    const newPassword = document.getElementById('newPassword').value;
    const confirmPassword = document.getElementById('confirmNewPassword').value;
    
    hideAllErrors();
    
    let hasError = false;
    
    if (!currentPassword) {
      currentPassError.textContent = 'მიმდინარე პაროლი აუცილებელია';
      currentPassError.style.display = 'block';
      hasError = true;
    }
    
    if (!newPassword) {
      newPassError.textContent = 'ახალი პაროლი აუცილებელია';
      newPassError.style.display = 'block';
      hasError = true;
    } else if (newPassword.length < 6) {
      newPassError.textContent = 'ახალი პაროლი უნდა იყოს მინიმუმ 6 სიმბოლო';
      newPassError.style.display = 'block';
      hasError = true;
    }
    
    if (!confirmPassword) {
      confirmPassError.textContent = 'გთხოვთ გაიმეოროთ ახალი პაროლი';
      confirmPassError.style.display = 'block';
      hasError = true;
    } else if (newPassword && newPassword !== confirmPassword) {
      confirmPassError.textContent = 'ახალი პაროლი არ ემთხვევა';
      confirmPassError.style.display = 'block';
      hasError = true;
    }
    
    if (hasError) return;
    
    try {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username]?.password !== currentPassword) {
        currentPassError.textContent = 'მიმდინარე პაროლი არასწორია';
        currentPassError.style.display = 'block';
        return;
      }
      
      users[currentUser.username].password = newPassword;
      localStorage.setItem('users', JSON.stringify(users));
      showNotification('პაროლი წარმატებით შეიცვალა', false);
      document.getElementById('passwordModalOverlay').remove();
    } catch (error) {
      console.error('Error changing password:', error);
      newPassError.textContent = 'შეცდომა პაროლის შეცვლისას';
      newPassError.style.display = 'block';
    }
  });
  
  cancelBtn.addEventListener('click', function() {
    document.getElementById('passwordModalOverlay').remove();
  });
  
  // Close on overlay click
  modalOverlay.addEventListener('click', function(e) {
    if (e.target === modalOverlay) {
      modalOverlay.remove();
    }
  });
}

// ==================== FIXED: RENDER MISTAKES LIST WITH MODULE NAME ====================
function renderMistakesList() {
  if (!currentUser || !currentTestType) {
    return '<div style="text-align:center; padding:20px; color:var(--muted);">აირჩიეთ მოდული შეცდომების სანახავად</div>';
  }
  
  const wrongQuestionIds = userProgress[currentTestType]?.wrongQuestions || [];
  
  // მოდულის სახელი ადამიანურად გასაგებად
  let moduleDisplayName = '';
  switch(currentTestType) {
    case 'rezidentura':
      moduleDisplayName = 'რეზიდენტურა';
      break;
    case 'internalMedicine':
      moduleDisplayName = 'შინაგანი მედიცინა';
      break;
    case 'pathology':
      moduleDisplayName = 'პათოლოგია';
      break;
    default:
      moduleDisplayName = currentTestType;
  }
  
  if (wrongQuestionIds.length === 0) {
    return `<div style="text-align:center; padding:20px; color:var(--muted);">მოდულში ${moduleDisplayName} შეცდომები არ არის!</div>`;
  }
  
  let html = `<div style="margin-bottom: 15px; padding: 10px; background: #f1f5f9; border-radius: 6px; text-align: center; font-weight: 600; color: var(--accent);">მოდული: ${moduleDisplayName}</div>`;
  
  wrongQuestionIds.forEach((questionId, index) => {
    const question = allTestsWithTopics[parseInt(questionId)];
    if (!question) return;
    
    const userAnswerData = userProgress[currentTestType]?.normal?.answeredQuestions[questionId] ||
                          userProgress[currentTestType]?.exam?.answeredQuestions[questionId];
    
    const userAnswerIndex = userAnswerData?.selectedAnswer;
    const userAnswerText = userAnswerIndex !== undefined ? 
      question.answers[userAnswerIndex]?.text : 'არ არის ცნობილი';
    
    const correctAnswer = question.answers.find(a => a.correct);
    const correctAnswerText = correctAnswer?.text || 'არ არის ცნობილი';
    
    html += `
      <div class="mistake-item">
        <div class="mistake-question">${escapeHtml(question.question)}</div>
        <div class="mistake-answers">
          <div class="mistake-user-answer">
            <strong>თქვენი პასუხი:</strong> ${escapeHtml(userAnswerText || 'არაა არჩეული')}
          </div>
          <div class="mistake-correct-answer">
            <strong>სწორი პასუხი:</strong> ${escapeHtml(correctAnswerText)}
          </div>
        </div>
      </div>
    `;
  });
  
  return html;
}

function printMistakes() {
  if (!currentUser || !currentTestType) {
    showNotification('შეცდომები არ არის');
    return;
  }
  
  const wrongQuestionIds = userProgress[currentTestType]?.wrongQuestions || [];
  
  if (wrongQuestionIds.length === 0) {
    showNotification('შეცდომები არ არის');
    return;
  }
  
  let printContent = `
    <html>
    <head>
      <title>შეცდომების ისტორია - ${currentUser.username}</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 1cm; }
        h1 { color: #0ea5a4; text-align: left; }
        .mistake { 
          margin-bottom: 30px; 
          padding: 20px; 
          border-left: 4px solid #dc2626;
          background: #f8fafc;
          border-radius: 8px;
        }
        .question { font-size: 16px; font-weight: 600; color: #1e293b; margin-bottom: 10px; }
        .user-answer { color: #dc2626; margin-bottom: 5px; }
        .correct-answer { color: #16a34a; }
        hr { margin: 20px 0; border: 1px solid #e2e8f0; }
        .date { color: #64748b; font-size: 12px; text-align: right; }
      </style>
    </head>
    <body>
      <h1>შეცდომების ისტორია</h1>
      <p style="text-align: left; color: #64748b;">მომხმარებელი: ${escapeHtml(currentUser.username)}</p>
      <p style="text-align: left; color: #64748b;">თარიღი: ${new Date().toLocaleDateString('ka-GE')}</p>
      <hr>
  `;
  
  wrongQuestionIds.forEach((questionId, index) => {
    const question = allTestsWithTopics[parseInt(questionId)];
    if (!question) return;
    
    const userAnswerData = userProgress[currentTestType]?.normal?.answeredQuestions[questionId] ||
                          userProgress[currentTestType]?.exam?.answeredQuestions[questionId];
    
    const userAnswerIndex = userAnswerData?.selectedAnswer;
    const userAnswerText = userAnswerIndex !== undefined ? 
      question.answers[userAnswerIndex]?.text : 'არ არის ცნობილი';
    
    const correctAnswer = question.answers.find(a => a.correct);
    const correctAnswerText = correctAnswer?.text || 'არ არის ცნობილი';
    
    printContent += `
      <div class="mistake">
        <div class="question">${index + 1}. ${escapeHtml(question.question)}</div>
        <div class="user-answer"><strong>თქვენი პასუხი:</strong> ${escapeHtml(userAnswerText)}</div>
        <div class="correct-answer"><strong>სწორი პასუხი:</strong> ${escapeHtml(correctAnswerText)}</div>
        <div class="date">${new Date(userAnswerData?.timestamp || Date.now()).toLocaleString('ka-GE')}</div>
      </div>
    `;
  });
  
  printContent += `</body></html>`;
  
  const printWindow = window.open('', '_blank');
  printWindow.document.write(printContent);
  printWindow.document.close();
  printWindow.focus();
  printWindow.print();
  printWindow.close();
}

function closeSettingsPage() {
  const settingsPage = document.getElementById('settingsPage');
  if (settingsPage) {
    settingsPage.remove();
  }
}

function bindUserMenuEvents() {
  const usernameBtn = document.getElementById('usernameBtn');
  const userDropdown = document.getElementById('userDropdown');
  
  if (usernameBtn) {
    usernameBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      userDropdown.classList.toggle('show');
    });
    
    document.addEventListener('click', () => {
      userDropdown.classList.remove('show');
    });
  }
  
  const changePasswordBtn = document.getElementById('changePasswordBtn');
  if (changePasswordBtn) {
    changePasswordBtn.addEventListener('click', () => {
      showPasswordChangeModal();
      userDropdown.classList.remove('show');
    });
  }
  
  document.getElementById('wrongQuestionsBtn').addEventListener('click', () => {
    startWrongQuestionsMode();
    userDropdown.classList.remove('show');
  });
  
  document.getElementById('settingsBtn').addEventListener('click', () => {
    showSettingsPage();
    userDropdown.classList.remove('show');
  });
  
  document.getElementById('signOutBtn').addEventListener('click', () => {
    saveUserProgress();
    currentUser = null;
    window._progressCheckPerformed = false; // გავასუფთავოთ ფლაგი
    location.reload();
  });
}

function checkAllQuestionsAnswered() {
  if (!examMode) return false;
  
  const allAnswered = sessionTests.every(q => 
    q.selectedAnswers && q.selectedAnswers.length > 0
  );
  
  const examFinishBtn = document.getElementById('examFinishBtn');
  
  if (examFinishBtn) {
    if (allAnswered) {
      examFinishBtn.style.display = 'flex';
    } else {
      examFinishBtn.style.display = 'flex'; // Keep visible even if not all answered, but can be disabled
    }
  }
  
  if (examTestBoxes) {
    const testBoxes = examTestBoxes.querySelectorAll('.test-box');
    testBoxes.forEach((box, index) => {
      if (sessionTests[index] && sessionTests[index].selectedAnswers && sessionTests[index].selectedAnswers.length > 0) {
        box.classList.add('answered');
      } else {
        box.classList.remove('answered');
      }
    });
  }
  
  return allAnswered;
}

function completeExam() {
  clearInterval(examTimerInterval);
  
  timerElement.classList.add('hidden');
  
  const correctCount = sessionTests.filter(q => 
    q.selectedAnswers && q.selectedAnswers.some(idx => q.answers[idx]?.correct)
  ).length;
  
  const passed = correctCount >= 150;
  
  examRightPanel.classList.add('hidden');
  
  const resultsHTML = `
    <div style="width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: #f8fafc; padding: 20px;">
      <div style="max-width: 800px; width: 100%; background: white; border-radius: 12px; box-shadow: 0 8px 30px rgba(0,0,0,0.15); overflow: hidden;">
        <div style="padding: 30px; border-bottom: 1px solid #e2e8f0;">
          <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 30px;">
            <div style="text-align: center; padding: 20px; background: #f0fdf4; border-radius: 8px;">
              <div style="font-size: 14px; color: #64748b; margin-bottom: 8px;">სწორი პასუხები</div>
              <div style="font-size: 42px; font-weight: 700; color: var(--success);">${correctCount}</div>
            </div>
            <div style="text-align: center; padding: 20px; background: #fef2f2; border-radius: 8px;">
              <div style="font-size: 14px; color: #64748b; margin-bottom: 8px;">არასწორი პასუხები</div>
              <div style="font-size: 42px; font-weight: 700; color: var(--danger);">${200 - correctCount}</div>
            </div>
          </div>
          
          <div style="text-align: center; padding: 15px; background: #f8fafc; border-radius: 8px;">
            <div style="font-size: 16px; color: #64748b; margin-bottom: 5px;">შეფასება</div>
            <div style="font-size: 28px; font-weight: 700; color: ${passed ? 'var(--success)' : 'var(--danger)'}">
              ${passed ? 'გამოცდა ჩაბარებულია' : 'ჩაჭრილია!'}
            </div>
            <div style="font-size: 18px; margin-top: 10px;">
              ${passed ? 'გილოცავთ! თქვენ წარმატებით ჩააბარეთ გამოცდა!' : 'სამწუხაროდ, თქვენ ვერ ჩააბარეთ გამოცდა. სცადეთ კიდევ.'}
            </div>
          </div>
        </div>
        
        <div style="padding: 30px;">
          <div style="font-size: 20px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;">
            შედეგების ისტორია
          </div>
          <div id="resultsHistoryContainer" style="max-height: 300px; overflow-y: auto; padding: 10px;">
          </div>
        </div>
        
        <div style="padding: 30px; background: #f8fafc; display: flex; gap: 15px; justify-content: center; border-top: 1px solid #e2e8f0;">
          <button id="viewDetailsBtn" style="padding: 12px 24px; background: var(--accent); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
            დეტალურად ნახვა
          </button>
          <button id="restartBtn" style="padding: 12px 24px; background: #10b981; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">
            თავიდან დაწყება
          </button>
        </div>
      </div>
    </div>
  `;
  
  testScreen.innerHTML = resultsHTML;
  
  const historyContainer = document.getElementById('resultsHistoryContainer');
  if (historyContainer) {
    sessionTests.forEach((question, index) => {
      const selectedAnswerIndex = question.selectedAnswers ? question.selectedAnswers[0] : -1;
      const isCorrect = selectedAnswerIndex !== -1 && question.answers[selectedAnswerIndex]?.correct;
      const selectedAnswer = selectedAnswerIndex !== -1 ? question.answers[selectedAnswerIndex].text : 'არაა არჩეული';
      const correctAnswer = question.answers.find(a => a.correct)?.text || 'არ არის ცნობილი';
      
      const resultItem = document.createElement('div');
      resultItem.style.cssText = 'padding: 12px; margin-bottom: 8px; background: white; border-radius: 6px; border-left: 4px solid ' + (isCorrect ? 'var(--success)' : 'var(--danger)') + ';';
      resultItem.innerHTML = `
        <div style="font-weight: 600; margin-bottom: 4px; font-size: 14px;">
          ${index + 1}. ${escapeHtml(question.question.substring(0, 80))}${question.question.length > 80 ? '...' : ''}
        </div>
        <div style="font-size: 13px; color: ${isCorrect ? 'var(--success)' : 'var(--danger)'}; margin-bottom: 2px;">
          <strong>თქვენი პასუხი:</strong> ${escapeHtml(selectedAnswer)}
        </div>
        ${!isCorrect ? `<div style="font-size: 13px; color: var(--success);"><strong>სწორი პასუხი:</strong> ${escapeHtml(correctAnswer)}</div>` : ''}
      `;
      historyContainer.appendChild(resultItem);
    });
  }
  
  setTimeout(() => {
    const restartBtn = document.getElementById('restartBtn');
    if (restartBtn) {
      restartBtn.addEventListener('click', () => {
        location.reload();
      });
    }
    
    const viewDetailsBtn = document.getElementById('viewDetailsBtn');
    if (viewDetailsBtn) {
      viewDetailsBtn.addEventListener('click', showDetailedResults);
    }
  }, 100);
}

function showDetailedResults() {
  detailedResultsContent.innerHTML = '';
  
  const table = document.createElement('table');
  table.style.cssText = 'width: 100%; border-collapse: collapse; font-size: 14px;';
  
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr style="background: #f1f5f9;">
      <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e2e8f0;">#</th>
      <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e2e8f0;">კითხვა</th>
      <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e2e8f0;">თქვენი პასუხი</th>
      <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e2e8f0;">სწორი პასუხი</th>
      <th style="padding: 12px; text-align: left; border-bottom: 2px solid #e2e8f0;">სტატუსი</th>
    </tr>
  `;
  table.appendChild(thead);
  
  const tbody = document.createElement('tbody');
  sessionTests.forEach((question, index) => {
    const selectedAnswerIndex = question.selectedAnswers ? question.selectedAnswers[0] : -1;
    const isCorrect = selectedAnswerIndex !== -1 && question.answers[selectedAnswerIndex]?.correct;
    const selectedAnswer = selectedAnswerIndex !== -1 ? question.answers[selectedAnswerIndex].text : 'არაა არჩეული';
    const correctAnswer = question.answers.find(a => a.correct)?.text || 'არ არის ცნობილი';
    
    const row = document.createElement('tr');
    row.style.borderBottom = '1px solid #e2e8f0';
    row.innerHTML = `
      <td style="padding: 12px; font-weight: 600;">${index + 1}</td>
      <td style="padding: 12px;">${escapeHtml(question.question.substring(0, 100))}${question.question.length > 100 ? '...' : ''}</td>
      <td style="padding: 12px; color: ${isCorrect ? 'var(--success)' : 'var(--danger)'};">${escapeHtml(selectedAnswer)}</td>
      <td style="padding: 12px; color: var(--success);">${escapeHtml(correctAnswer)}</td>
      <td style="padding: 12px;">
        <span style="padding: 4px 8px; border-radius: 4px; font-weight: 600; background: ${isCorrect ? '#d1fae5' : '#fee2e2'}; color: ${isCorrect ? '#065f46' : '#991b1b'}">
          ${isCorrect ? 'სწორი' : 'არასწორი'}
        </span>
      </td>
    `;
    tbody.appendChild(row);
  });
  
  table.appendChild(tbody);
  detailedResultsContent.appendChild(table);
  
  detailedResultsModal.classList.add('active');
}

// ==================== FIXED: SHOW PASSWORD MODAL WITHOUT CLOSING SETTINGS ====================
function showPasswordChangeModalWithoutClose() {
  // Don't close settings page, just show modal on top
  const modalHTML = `
    <div class="modal-overlay active" id="passwordModalOverlay" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10002;">
      <div class="modal" style="background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
        <div class="modal-header" style="font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;">პაროლის შეცვლა</div>
        <div class="modal-content" style="margin-bottom: 30px;">
          <div style="margin-bottom: 20px;">
            <input type="password" id="currentPassword" placeholder="მიმდინარე პაროლი" class="auth-input" style="width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 15px;">
            <input type="password" id="newPassword" placeholder="ახალი პაროლი (მინიმუმ 6 სიმბოლო)" class="auth-input" style="width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px; margin-bottom: 15px;">
            <input type="password" id="confirmNewPassword" placeholder="გაიმეორეთ ახალი პაროლი" class="auth-input" style="width: 100%; padding: 14px 16px; border: 2px solid #e2e8f0; border-radius: 10px; font-size: 15px;">
          </div>
        </div>
        <div class="modal-buttons" style="display: flex; gap: 15px; justify-content: center;">
          <button id="savePasswordBtn" class="modal-btn confirm" style="padding: 12px 24px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">განახლება</button>
          <button id="cancelPasswordBtn" class="modal-btn cancel" style="padding: 12px 24px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: 600; cursor: pointer;">გაუქმება</button>
        </div>
      </div>
    </div>
  `;
  
  const modalContainer = document.createElement('div');
  modalContainer.innerHTML = modalHTML;
  document.body.appendChild(modalContainer.firstChild);
  
  document.getElementById('savePasswordBtn').addEventListener('click', () => {
    const currentPassword = document.getElementById('currentPassword').value;
    const newPassword = document.getElementById('newPassword').value;
    const confirmPassword = document.getElementById('confirmNewPassword').value;
    
    if (!currentPassword || !newPassword || !confirmPassword) {
      showNotification('გთხოვთ შეავსოთ ყველა ველი');
      return;
    }
    
    if (newPassword.length < 6) {
      showNotification('ახალი პაროლი უნდა იყოს მინიმუმ 6 სიმბოლო');
      return;
    }
    
    if (newPassword !== confirmPassword) {
      showNotification('ახალი პაროლი არ ემთხვევა');
      return;
    }
    
    try {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username]?.password !== currentPassword) {
        showNotification('მიმდინარე პაროლი არასწორია');
        return;
      }
      
      users[currentUser.username].password = newPassword;
      localStorage.setItem('users', JSON.stringify(users));
      showNotification('პაროლი წარმატებით შეიცვალა', false);
      document.getElementById('passwordModalOverlay').remove();
    } catch (error) {
      console.error('Error changing password:', error);
      showNotification('შეცდომა პაროლის შეცვლისას');
    }
  });
  
  document.getElementById('cancelPasswordBtn').addEventListener('click', () => {
    document.getElementById('passwordModalOverlay').remove();
  });
}

// ==================== CSV LOADING FUNCTIONS ====================
function loadCSV() {
  loaderOverlay.style.display = 'flex';
  resetLoader();
  startBtn.disabled = true;
  
  // მიმდინარე არჩეული ტესტის ტიპი
  const testType = document.getElementById('testTypeSelect').value;
  
  let csvUrl;
  
  // სხვადასხვა ტესტის ლინკები
  if (testType === 'rezidentura') {
    csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTAKLvhjOkhFoadqGeDcS_T74DdtGNqLPY30zld05OjmbwwP_i-anVEF0uNNTtb29NoPKLm6XTAxIGu/pub?gid=69945858&single=true&output=csv";
  } else if (testType === 'internalMedicine') {
    csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTAKLvhjOkhFoadqGeDcS_T74DdtGNqLPY30zld05OjmbwwP_i-anVEF0uNNTtb29NoPKLm6XTAxIGu/pub?gid=779421848&single=true&output=csv";
  } else if (testType === 'pathology') {
    csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTAKLvhjOkhFoadqGeDcS_T74DdtGNqLPY30zld05OjmbwwP_i-anVEF0uNNTtb29NoPKLm6XTAxIGu/pub?gid=150316971&single=true&output=csv";
  } else {
    // default
    csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTAKLvhjOkhFoadqGeDcS_T74DdtGNqLPY30zld05OjmbwwP_i-anVEF0uNNTtb29NoPKLm6XTAxIGu/pub?gid=69945858&single=true&output=csv";
  }
  
  fetch(csvUrl).then(r => {
    if (!r.ok) throw new Error('Network error: ' + r.status);
    return r.text();
  }).then(txt => {
    console.log("CSV raw text length:", txt.length);
    
    const twoColRows = parseCSVTwoColumns(txt);
    console.log("Parsed rows:", twoColRows.length);
    
    allTestsWithTopics = buildTestsFromCSV(twoColRows);
    console.log("Built tests:", allTestsWithTopics.length);
    
    allTests = allTestsWithTopics;
    
    if (!allTests.length){
      showNotification('ვერ მოიძებნა ტესტები. შეამოწმეთ ფაილი.');
      loaderOverlay.innerHTML = '<div style="color: var(--danger); font-weight: 600; text-align: center; padding: 20px;">ტესტები ვერ მოიძებნა<br><small>გთხოვთ განაახლოთ გვერდი</small></div>';
      startBtn.disabled = false;
      return;
    }
    
    totalQuestionsEl.textContent = allTests.length;
    
    extractTopics();
    console.log("Available topics:", Array.from(availableTopics));
    
    populateTopicsList();

    loaderOverlay.style.display = 'none';
    startBtn.disabled = false;

    // ==== შესწორებული ნაწილი: პროგრესის შემოწმება - მხოლოდ ერთხელ ====
    if (currentUser && !currentUser.isGuest) {
      // გადავამოწმოთ, რომ არ არის გამოცდის რეჟიმი მონიშნული
      const modeExamCheckbox = document.getElementById('modeExam');
      if (modeExamCheckbox && !modeExamCheckbox.checked) {
        // გამოვიყენოთ ფლაგი, რომ მხოლოდ ერთხელ შევამოწმოთ
        if (!window._progressCheckPerformed) {
          window._progressCheckPerformed = true;
          setTimeout(() => {
            checkExistingProgress();
            window.pendingProgressCheck = false;
          }, 500);
        }
      } else {
        console.log("Exam mode is checked or checkbox not found, skipping progress check");
      }
    }
    // ==== შესწორებული ნაწილის დასასრული ====
    
  }).catch(err => {
    console.error("Fetch error:", err);
    showNotification('შეცდომა ფაილის ჩატვირთვისას: ' + err.message);
    loaderOverlay.innerHTML = `<div style="color: var(--danger); font-weight: 600; text-align: center; padding: 20px;">შეცდომა ჩატვირთვისას<br><small>${err.message}</small></div>`;
    startBtn.disabled = false;
  });
}

function parseCSVTwoColumns(csvText){
  if (!csvText) return [];
  
  csvText = csvText.trim();
  csvText = csvText.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  
  const rows = [];
  const lines = csvText.split('\n');
  
  for (let line of lines) {
    line = line.trim();
    if (!line) continue;
    
    let columns = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      const next = line[i + 1];
      
      if (ch === '"') {
        if (inQuotes && next === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
        continue;
      } else if (ch === ',' && !inQuotes) {
        columns.push(current.trim());
        current = '';
        continue;
      }
      current += ch;
    }
    
    columns.push(current.trim());
    
    if (columns.length === 1) {
      columns.push('');
    }
    
    rows.push({
      columnA: columns[0],
      columnB: columns[1] || ''
    });
  }
  
  return rows;
}

function buildTestsFromCSV(rawRows){
  console.log("=== BUILDING TESTS FROM 2-COLUMN CSV ===");
  
  const tests = [];
  let currentTest = null;
  let currentTopic = 'ზოგადი';
  
  for (let i = 0; i < rawRows.length; i++){
    const columnA = rawRows[i].columnA;
    const columnB = rawRows[i].columnB;
    
    if (!columnA && !columnB) continue;
    
    const normalizedA = normalizeLine(columnA);
    const topic = normalizeLine(columnB);
    
    if (topic && topic !== '') {
      currentTopic = topic;
    }
    
    const type = detectLineType(normalizedA);
    
    if (type === 'question'){
      if (currentTest && currentTest.answers.length > 0) {
        currentTest.topic = currentTopic;
        tests.push(currentTest);
      }
      
      currentTest = { 
        raw: normalizedA, 
        question: stripLeadingSymbol(normalizedA), 
        topic: currentTopic,
        answers: [], 
        sourceIndex: i 
      };
      
    } else if ((type === 'correct' || type === 'incorrect') && currentTest){
      const isCorrect = (type === 'correct');
      const txt = stripLeadingSymbol(normalizedA);
      if (txt.length > 0) {
        currentTest.answers.push({ 
          text: txt, 
          correct: isCorrect,
          originalText: txt
        });
      }
    }
  }
  
  if (currentTest && currentTest.answers.length > 0) {
    currentTest.topic = currentTopic;
    tests.push(currentTest);
  }
  
  console.log(`Built ${tests.length} tests from CSV`);
  
  const filteredTests = tests.filter(t => Array.isArray(t.answers) && t.answers.length > 0);
  
  const topicCounts = {};
  filteredTests.forEach(test => {
    const topic = test.topic || 'ზოგადი';
    topicCounts[topic] = (topicCounts[topic] || 0) + 1;
  });
  
  console.log("Topic distribution:", topicCounts);
  
  return filteredTests;
}

function normalizeLine(raw){
  if (raw == null) return '';
  let s = String(raw).normalize('NFKC');
  s = s.replace(/^\uFEFF/, '');
  s = s.replace(/[\u200B-\u200F\uFEFF]/g, '');
  s = s.replace(/^"+|"+$/g, '');
  s = s.replace(/\s+/g, ' ');
  return s.trim();
}

function detectLineType(line){
  const s = line.trim();
  if (!s) return 'unknown';
  
  if (/^¢/.test(s)) {
    return 'question';
  }
  
  if (/^(✔️|✔|✓|✅|\+)/.test(s)) {
    return 'correct';
  }
  
  if (/^(❌|✖️|✖|✕|✗|✘|-)/.test(s)) {
    return 'incorrect';
  }
  
  if (/[ა-ჰ]/.test(s) && /\?$/.test(s)) {
    return 'question';
  }
  
  return 'unknown';
}

function stripLeadingSymbol(str) {
  if (!str) return '';
  
  let cleaned = str.replace(/^¢\s*(ID=\d+\s*)?/, '').trim();
  
  cleaned = cleaned.replace(/^[✔️✔✓✅+❌✖️✖✕✗✘\-]\s*/, '');
  
  return cleaned;
}

function extractTopics() {
  availableTopics.clear();
  
  allTestsWithTopics.forEach(test => {
    if (test.topic && test.topic.trim() !== '') {
      availableTopics.add(test.topic.trim());
    } else {
      availableTopics.add('ზოგადი');
    }
  });
}

function populateTopicsList() {
  const topicsSelect = document.getElementById('topicsSelect');
  if (!topicsSelect) return;
  
  topicsSelect.innerHTML = '<option value="all" selected>ტესტები თემების მიხედვით</option>';
  
  const topicCounts = {};
  allTestsWithTopics.forEach(test => {
    const topic = test.topic && test.topic.trim() !== '' ? test.topic.trim() : 'ზოგადი';
    topicCounts[topic] = (topicCounts[topic] || 0) + 1;
  });
  
  const topicsInOrder = [];
  const seenTopics = new Set();
  
  allTestsWithTopics.forEach(test => {
    const topic = test.topic && test.topic.trim() !== '' ? test.topic.trim() : 'ზოგადი';
    if (!seenTopics.has(topic)) {
      seenTopics.add(topic);
      topicsInOrder.push(topic);
    }
  });
  
  const sortedTopics = topicsInOrder;
  
  sortedTopics.forEach(topic => {
    const count = topicCounts[topic] || 0;
    const option = document.createElement('option');
    option.value = topic;
    option.textContent = `${topic} (${count})`;
    topicsSelect.appendChild(option);
  });
  
  topicsSelect.addEventListener('change', function() {
    updateSelectedTopics();
  });
  
  toggleTopicsDropdown();
}

function updateSelectedTopics() {
  const topicsSelect = document.getElementById('topicsSelect');
  if (!topicsSelect) return;
  
  const selectedValue = topicsSelect.value;
  
  if (selectedValue === 'all') {
    selectedTopic = null;
  } else {
    selectedTopic = selectedValue;
  }
  
  // დაიმახსოვრეთ მიმდინარე ტესტის ტიპი
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (testTypeSelect) {
    currentTestType = testTypeSelect.value;
  }
}

// ==================== FIXED: START TEST WITH PROGRESS ====================
function startTest() {
  // არ შევამოწმოთ პროგრესი აქ, რადგან უკვე შევამოწმეთ loadCSV-ში
  // if (currentUser && !currentUser.isGuest && allTestsWithTopics.length > 0) {
  //   checkExistingProgress();
  // }
  
  window.savedProgress = null;
  
  if (modeSequential.checked && modeShuffleQuestions.checked) {
    showNotification('ეს რეჟიმები ერთად შეუძლებელია არსებობდეს!');
    return;
  }
  
  const topicsSelect = document.getElementById('topicsSelect');
  if (topicsSelect) {
    const selectedValue = topicsSelect.value;
    
    if (!selectedValue || selectedValue === '') {
      showNotification('გთხოვთ აირჩიოთ თემა!');
      return;
    }
  }
  
  autoMode = false;
  isWrongQuestionsMode = false; // გადატვირთეთ რეჟიმი
  
  examMode = modeExam.checked;
  const shuffleQuestions = modeShuffleQuestions.checked || examMode;
  const shuffleAnswers = modeShuffleAnswers.checked;
  
  let testsToUse = allTestsWithTopics;
  
  if (selectedTopic && selectedTopic !== 'all') {
    testsToUse = allTestsWithTopics.filter(test => {
      const testTopic = test.topic && test.topic.trim() !== '' ? test.topic.trim() : 'ზოგადი';
      return testTopic === selectedTopic;
    });
    
    if (testsToUse.length === 0) {
      showNotification(`არჩეულ თემას არ გააჩნია ტესტები`);
      return;
    }
  }
  
  if (examMode) {
    const shuffledAll = [...testsToUse];
    shuffleArray(shuffledAll);
    sessionTests = shuffledAll.slice(0, Math.min(200, shuffledAll.length)).map((t, idx) => ({ 
      id: idx.toString(), // For exam mode, we use index as ID (temporary)
      question: t.question, 
      answers: t.answers.map(a => ({...a})),
      selectedAnswers: [],
      hasCorrectAnswer: false,
      isAnswerCorrect: null
    }));
  } else {
    sessionTests = testsToUse.map((t, idx) => ({ 
      id: idx.toString(), // For normal mode, we use index as ID
      originalId: idx.toString(), // Store original index for reference
      question: t.question, 
      answers: t.answers.map(a => ({...a})),
      selectedAnswers: [],
      hasCorrectAnswer: false,
      isAnswerCorrect: null
    }));
  }
  
  // In startTest function, this part is correct:
  if (window.savedProgress && currentUser && !currentUser.isGuest) {
    const progress = window.savedProgress;
    const mode = examMode ? 'exam' : 'normal';
    
    if (progress[mode] && progress[mode].answeredQuestions) {
      // FIXED: Find the last answered question to continue from next
      let lastAnsweredIndex = -1;
      
      Object.keys(progress[mode].answeredQuestions).forEach(questionId => {
        const idx = parseInt(questionId);
        if (idx < sessionTests.length) {
          const answerData = progress[mode].answeredQuestions[questionId];
          sessionTests[idx].selectedAnswers = [answerData.selectedAnswer];
          sessionTests[idx].hasCorrectAnswer = answerData.isCorrect;
          sessionTests[idx].isAnswerCorrect = answerData.isCorrect;
          
          // Track the highest index answered
          if (idx > lastAnsweredIndex) {
            lastAnsweredIndex = idx;
          }
        }
      });
      
      // FIXED: Start from the next unanswered question (lastAnsweredIndex + 1)
      if (lastAnsweredIndex >= 0 && lastAnsweredIndex < sessionTests.length - 1) {
        currentIndex = lastAnsweredIndex + 1;
      } else if (lastAnsweredIndex === sessionTests.length - 1) {
        // If all questions are answered, stay at the last one
        currentIndex = lastAnsweredIndex;
      } else {
        currentIndex = progress[mode].currentIndex || 0;
      }
      
      // FIXED: Load exam time remaining
      if (examMode && progress.exam && progress.exam.examTimeRemaining) {
        examTimeRemaining = progress.exam.examTimeRemaining;
        lastTimerUpdate = Date.now(); // Reset the last update time
      }
      
      showNotification('პროგრესი წარმატებით ჩაიტვირთა', false);
    }
    window.savedProgress = null;
  }
  
  if (shuffleQuestions && !examMode) {
    shuffleArray(sessionTests);
  }

  if (shuffleAnswers) {
    sessionTests.forEach(q => shuffleArray(q.answers));
  }
  
  optionsScreen.style.display = 'none';
  testScreen.classList.add('active');
  
  if (selectedTopic && selectedTopic !== 'all') {
    timerElement.innerHTML = `
      <span style="font-weight: 600; color: var(--accent);">${currentUser ? currentUser.username : 'სტუმარი'}</span>
      <span class="timer-separator">|</span>
      <span class="timer-time">${new Date().toLocaleTimeString('ka-GE')}</span>
      <br>
      <span class="timer-topic">თემა: ${selectedTopic}</span>
    `;
  }
  
  if (examMode) {
    startExamMode();
  } else {
    normalModeContainer.classList.remove('hidden');
    examModeContainer.classList.add('hidden');
    examRightPanel.classList.add('hidden');
    
    questionCounter.classList.remove('hidden');
    currentQuestionEl.textContent = currentIndex + 1;
    totalQuestionsEl.textContent = sessionTests.length;
    
    timerElement.classList.remove('hidden');
  }
  
  renderCurrentQuestion();
}

function renderCurrentQuestion() {
  if (!sessionTests.length) return;
  
  const question = sessionTests[currentIndex];
  
  if (examMode) {
    examQuestionText.textContent = question.question;
    
    createExamTestBoxes();
    
    renderExamAnswers();
    
    checkAllQuestionsAnswered();
  } else {
    questionText.textContent = question.question;
    
    currentQuestionEl.textContent = currentIndex + 1;
    totalQuestionsEl.textContent = sessionTests.length;
    
    if (isEditingQuestionNumber) {
      currentQuestionEl.classList.remove('editing');
      isEditingQuestionNumber = false;
    }
    
    renderNormalAnswers();
  }
}

// ==================== FIXED: RENDER NORMAL ANSWERS WITH PROPER WRONG QUESTIONS CHECK ====================
function renderNormalAnswers() {
  const question = sessionTests[currentIndex];
  answersContainer.innerHTML = '';
  feedback.innerHTML = '';
  
  if (question.answers && question.answers.length > 0) {
    question.answers.forEach((answer, idx) => {
      const answerEl = document.createElement('div');
      answerEl.className = 'answer-item';
      
      const wasSelected = question.selectedAnswers && question.selectedAnswers.includes(idx);
      
      if (wasSelected) {
        answerEl.classList.add('selected');
        if (answer.correct) {
          answerEl.classList.add('correct');
        } else {
          answerEl.classList.add('incorrect');
        }
      }
      
      answerEl.innerHTML = `
        <span class="answer-number">${idx + 1}.</span>
        <span class="answer-text">${escapeHtml(answer.text)}</span>
      `;
      
      answerEl.addEventListener('click', () => {
        if (wasSelected) return;
        
        if (!question.selectedAnswers) {
          question.selectedAnswers = [];
        }
        
        question.selectedAnswers.push(idx);
        
        answerEl.classList.add('selected');
        
        if (answer.correct) {
          answerEl.classList.add('correct');
          if (!question.hasCorrectAnswer) {
            question.hasCorrectAnswer = true;
          }
          feedback.innerHTML = `<div style="color:var(--success); font-size:16px; font-weight:600;">✓ სწორი პასუხი!</div>`;
          
          // Update progress with the original question ID
          updateUserProgress(question.id, idx, true, false);
          
          if (autoMode && currentIndex < sessionTests.length - 1) {
            setTimeout(() => {
              currentIndex++;
              autoSaveProgress();
              renderCurrentQuestion();
            }, 500);
          } else {
            // FIXED: Check if we're in wrong questions mode and all wrong questions are gone
            if (isWrongQuestionsMode) {
              setTimeout(() => {
                const wrongQuestionsAfter = getWrongQuestions();
                console.log("Wrong questions after:", wrongQuestionsAfter.length);
                console.log("Session tests length:", sessionTests.length);
                
                // If we're in wrong questions mode and there are no wrong questions left
                if (wrongQuestionsAfter.length === 0) {
                  console.log("Showing exhausted modal!");
                  showWrongQuestionsExhaustedModal();
                }
              }, 200);
            }
          }
          
        } else {
          answerEl.classList.add('incorrect');
          feedback.innerHTML = `<div style="color:var(--danger); font-size:16px; font-weight:600;">✗ არასწორი პასუხი</div>`;
          
          updateUserProgress(question.id, idx, false, false);
        }
        
        autoSaveProgress();
        renderCurrentQuestion();
      });
      
      answersContainer.appendChild(answerEl);
    });
  } else {
    answersContainer.innerHTML = '<div style="text-align:center; color:var(--muted); padding:20px;">პასუხები არ მოიძებნა</div>';
  }
  
  if (prevBtn && nextBtn) {
    prevBtn.disabled = currentIndex === 0;
    nextBtn.disabled = currentIndex === sessionTests.length - 1;
  }
  
  updateAutoButton();
}

// ==================== FIXED: HANDLE WRONG QUESTIONS MODE COMPLETION ====================
function handleWrongQuestionsCompletion() {
  // Check if we're in wrong questions mode
  const wrongQuestions = getWrongQuestions();
  
  // If there are no wrong questions and we're currently in a session that matches the previous wrong questions count
  if (wrongQuestions.length === 0 && sessionTests.length > 0) {
    // Check if this session was likely the wrong questions session
    // We can check by seeing if all questions in sessionTests have been answered correctly
    const allCorrectInSession = sessionTests.every(q => 
      q.hasCorrectAnswer === true
    );
    
    if (allCorrectInSession) {
      showWrongQuestionsExhaustedModal();
    }
  }
}

function renderExamAnswers() {
  const question = sessionTests[currentIndex];
  examAnswersContainer.innerHTML = '';
  examFeedback.innerHTML = '';
  
  if (question.answers && question.answers.length > 0) {
    question.answers.forEach((answer, idx) => {
      const answerEl = document.createElement('div');
      answerEl.className = 'exam-answer-item';
      
      const wasSelected = question.selectedAnswers && question.selectedAnswers.includes(idx);
      
      if (wasSelected) {
        answerEl.classList.add('selected');
      }
      
      answerEl.innerHTML = `
        <span class="exam-answer-number">${idx + 1}.</span>
        <span class="answer-text">${escapeHtml(answer.text)}</span>
      `;
      
      answerEl.addEventListener('click', () => {
        if (wasSelected) return;
        
        if (!question.selectedAnswers) {
          question.selectedAnswers = [];
        }
        
        question.selectedAnswers = [idx];
        
        question.isAnswerCorrect = answer.correct;
        
        answerEl.classList.add('selected');
        examFeedback.innerHTML = '';
        
        createExamTestBoxes();
        
        updateUserProgress(question.id, idx, answer.correct, true);
        
        onAnswerSelected();
        autoSaveProgress();
        renderCurrentQuestion();
      });
      
      examAnswersContainer.appendChild(answerEl);
    });
  } else {
    examAnswersContainer.innerHTML = '<div style="text-align:center; color:var(--muted); padding:20px;">პასუხები არ მოიძებნა</div>';
  }
  
  if (examPrevBtn && examNextBtn) {
    examPrevBtn.disabled = currentIndex === 0;
    examNextBtn.disabled = currentIndex === sessionTests.length - 1;
  }
  
  updateExamAutoButton();
}

function onAnswerSelected() {
  checkAllQuestionsAnswered();
}

function autoSaveProgress() {
  if (!currentUser || currentUser.isGuest || !currentTestType) return;
  
  const mode = examMode ? 'exam' : 'normal';
  
  if (!userProgress[currentTestType]) {
    userProgress[currentTestType] = {
      normal: { answeredQuestions: {}, currentIndex: 0 },
      exam: { answeredQuestions: {}, currentIndex: 0 },
      wrongQuestions: []
    };
  }
  
  if (!userProgress[currentTestType][mode]) {
    userProgress[currentTestType][mode] = { answeredQuestions: {}, currentIndex: 0 };
  }
  
  userProgress[currentTestType][mode].currentIndex = currentIndex;
  
  if (examMode) {
    // Save remaining time
    userProgress[currentTestType].exam.examTimeRemaining = examTimeRemaining;
  }
  
  saveUserProgress();
}

function updateAutoButton() {
  if (!autoBtn || !nextBtn) return;
  
  if (autoMode) {
    nextBtn.classList.add('vanish-effect');
    autoBtn.textContent = 'გამორთე Auto';
  } else {
    nextBtn.classList.remove('vanish-effect');
    autoBtn.textContent = 'Auto';
  }
}

function updateExamAutoButton() {
  if (!examAutoBtn || !examNextBtn) return;
  
  if (autoMode) {
    examNextBtn.classList.add('vanish-effect');
    examAutoBtn.textContent = 'გამორთე Auto';
  } else {
    examNextBtn.classList.remove('vanish-effect');
    examAutoBtn.textContent = 'Auto';
  }
}

function bindNavigationEvents() {
  prevBtn = document.getElementById('prevBtn');
  nextBtn = document.getElementById('nextBtn');
  autoBtn = document.getElementById('autoBtn');
  
  examPrevBtn = document.getElementById('examPrevBtn');
  examNextBtn = document.getElementById('examNextBtn');
  examAutoBtn = document.getElementById('examAutoBtn');
  examFinishBtn = document.getElementById('examFinishBtn');
  
  if (prevBtn) {
    prevBtn.addEventListener('click', () => {
      if (currentIndex > 0) {
        currentIndex--;
        autoSaveProgress();
        renderCurrentQuestion();
      }
    });
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', () => {
      if (currentIndex < sessionTests.length - 1) {
        currentIndex++;
        autoSaveProgress();
        renderCurrentQuestion();
      } else if (examMode) {
        completeExam();
      } else {
        showCompletionScreen();
      }
    });
  }
  
  if (autoBtn) {
    autoBtn.addEventListener('click', () => {
      autoMode = !autoMode;
      updateAutoButton();
      updateExamAutoButton();
    });
  }
  
  if (examPrevBtn) {
    examPrevBtn.addEventListener('click', () => {
      if (currentIndex > 0) {
        currentIndex--;
        autoSaveProgress();
        renderCurrentQuestion();
      }
    });
  }
  
  if (examNextBtn) {
    examNextBtn.addEventListener('click', () => {
      if (currentIndex < sessionTests.length - 1) {
        currentIndex++;
        autoSaveProgress();
        renderCurrentQuestion();
      } else {
        if (checkAllQuestionsAnswered()) {
          completeExam();
        } else {
          showNotification('გთხოვთ უპასუხოთ ყველა კითხვას გამოცდის დასრულებამდე');
        }
      }
    });
  }
  
  if (examAutoBtn) {
    examAutoBtn.addEventListener('click', () => {
      autoMode = !autoMode;
      updateAutoButton();
      updateExamAutoButton();
    });
  }
  
  if (examFinishBtn) {
    examFinishBtn.addEventListener('click', () => {
      if (examMode) {
        if (checkAllQuestionsAnswered()) {
          completeExam();
        } else {
          showNotification('გთხოვთ უპასუხოთ ყველა კითხვას გამოცდის დასრულებამდე');
        }
      }
    });
  }
  
  const closeDetailsBtn = document.getElementById('closeDetailsBtn');
  if (closeDetailsBtn) {
    closeDetailsBtn.addEventListener('click', () => {
      detailedResultsModal.classList.remove('active');
    });
  }
}

function bindQuestionCounterEvent() {
  if (!currentQuestionEl) return;
  
  currentQuestionEl.addEventListener('click', (e) => {
    e.stopPropagation();
    
    if (isEditingQuestionNumber || examMode) return;
    
    isEditingQuestionNumber = true;
    currentQuestionEl.classList.add('editing');
    
    const originalValue = currentQuestionEl.textContent;
    
    const input = document.createElement('input');
    input.type = 'number';
    input.value = originalValue;
    input.min = 1;
    input.max = sessionTests.length;
    input.style.cssText = `
      width: 60px;
      height: 40px;
      font-size: 28px;
      font-weight: 700;
      text-align: center;
      border: none;
      background: transparent;
      color: var(--success);
      outline: none;
      padding: 0;
      margin: 0;
      -moz-appearance: textfield;
    `;
    
    input.style.webkitAppearance = 'none';
    input.style.margin = '0';
    
    const originalDisplay = currentQuestionEl.style.display;
    currentQuestionEl.style.display = 'none';
    
    const inputContainer = document.createElement('div');
    inputContainer.style.cssText = `
      display: inline-block;
      min-width: 50px;
      text-align: center;
    `;
    inputContainer.appendChild(input);
    
    currentQuestionEl.parentNode.insertBefore(inputContainer, currentQuestionEl.nextSibling);
    
    input.focus();
    input.select();
    
    const handleInputComplete = () => {
      const value = parseInt(input.value);
      if (value >= 1 && value <= sessionTests.length) {
        currentIndex = value - 1;
        
        inputContainer.remove();
        currentQuestionEl.style.display = originalDisplay;
        currentQuestionEl.textContent = value;
        currentQuestionEl.classList.remove('editing');
        isEditingQuestionNumber = false;
        
        autoSaveProgress();
        renderCurrentQuestion();
      } else {
        inputContainer.remove();
        currentQuestionEl.style.display = originalDisplay;
        currentQuestionEl.classList.remove('editing');
        isEditingQuestionNumber = false;
        
        showNotification('გთხოვთ შეიყვანოთ ნომერი 1-დან ' + sessionTests.length + '-მდე');
      }
    };
    
    input.addEventListener('blur', handleInputComplete);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        handleInputComplete();
      }
    });
    
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        inputContainer.remove();
        currentQuestionEl.style.display = originalDisplay;
        currentQuestionEl.classList.remove('editing');
        isEditingQuestionNumber = false;
      }
    });
  });
}

// ==================== FIXED: CHECK EXISTING PROGRESS ====================
function checkExistingProgress() {
  // არ შევამოწმოთ პროგრესი თუ გამოცდის რეჟიმია მონიშნული
  if (document.getElementById('modeExam') && document.getElementById('modeExam').checked) {
    console.log("Exam mode is checked, skipping progress check");
    return;
  }
  
  if (!currentUser || currentUser.isGuest || !allTestsWithTopics.length) return;
  
  // მიმდინარე არჩეული მოდული
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (!testTypeSelect || testTypeSelect.value === '') return;
  
  const selectedModule = testTypeSelect.value;
  console.log("Checking progress for module:", selectedModule);
  
  // შევამოწმოთ არჩეული მოდულის პროგრესი
  const progress = userProgress[selectedModule];
  if (!progress) return;
  
  const hasNormalProgress = progress.normal && 
                           Object.keys(progress.normal.answeredQuestions || {}).length > 0;
  const hasExamProgress = progress.exam && 
                         Object.keys(progress.exam.answeredQuestions || {}).length > 0;
  
  if (!hasNormalProgress && !hasExamProgress) return;
  
  // გამოვთვალოთ გაკეთებული ტესტების რაოდენობა
  const normalCount = hasNormalProgress ? Object.keys(progress.normal.answeredQuestions || {}).length : 0;
  const examCount = hasExamProgress ? Object.keys(progress.exam.answeredQuestions || {}).length : 0;
  const totalAnswered = normalCount + examCount;
  
  // მოდულის სახელი ადამიანურად გასაგებად
  let moduleDisplayName = '';
  switch(selectedModule) {
    case 'rezidentura':
      moduleDisplayName = 'რეზიდენტურა';
      break;
    case 'internalMedicine':
      moduleDisplayName = 'შინაგანი მედიცინა';
      break;
    case 'pathology':
      moduleDisplayName = 'პათოლოგია';
      break;
    default:
      moduleDisplayName = selectedModule;
  }
  
  // გამოვიძახოთ მოდალი შესაბამისი ინფორმაციით
  showProgressResumeModal(totalAnswered, moduleDisplayName, progress, selectedModule);
}

// ==================== FIXED: SHOW PROGRESS RESUME MODAL WITH MODULE NAME ====================
function showProgressResumeModal(totalAnswered, moduleName, progress, selectedModule) {
  console.log("Showing progress resume modal for module:", moduleName, "total:", totalAnswered);
  
  // თუ უკვე გვაქვს ღია მოდალი, აღარ გავხსნათ ახალი
  const existingModal = document.querySelector('.modal-overlay[data-type="progress-resume"]');
  if (existingModal) {
    console.log("Modal already exists, not creating another");
    return;
  }
  
  const modalOverlay = document.createElement('div');
  modalOverlay.className = 'modal-overlay active';
  modalOverlay.setAttribute('data-type', 'progress-resume');
  modalOverlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 10001;';
  
  const modal = document.createElement('div');
  modal.className = 'modal';
  modal.style.cssText = 'background: white; border-radius: 16px; padding: 30px; max-width: 500px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.3);';
  
  // Modal Header
  const header = document.createElement('div');
  header.className = 'modal-header';
  header.style.cssText = 'font-size: 24px; font-weight: 600; color: #1e293b; margin-bottom: 20px; text-align: center;';
  header.textContent = 'გსურთ გაგრძელება?';
  
  // Modal Content
  const content = document.createElement('div');
  content.className = 'modal-content';
  content.style.cssText = 'margin-bottom: 30px; text-align: center;';
  
  const p1 = document.createElement('p');
  p1.style.cssText = 'margin-bottom: 15px; font-size: 16px;';
  p1.innerHTML = `თქვენ უკვე გაქვთ <strong style="color: var(--accent);">${totalAnswered} ტესტი</strong> დაწერილი მოდულში: <strong style="color: var(--accent);">${moduleName}</strong>`;
  
  const p2 = document.createElement('p');
  p2.style.cssText = 'margin-bottom: 20px; color: #64748b;';
  p2.textContent = 'გსურთ გააგრძელოთ ბოლო ტესტიდან თუ თავიდან დაიწყოთ?';
  
  content.appendChild(p1);
  content.appendChild(p2);
  
  // Modal Buttons
  const buttons = document.createElement('div');
  buttons.style.cssText = 'display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;';
  
  const continueBtn = document.createElement('button');
  continueBtn.id = 'continueProgressBtn';
  continueBtn.style.cssText = 'padding: 12px 20px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer; min-width: 120px; flex: 1 1 auto;';
  continueBtn.textContent = 'გაგრძელება';
  
  const restartBtn = document.createElement('button');
  restartBtn.id = 'restartProgressBtn';
  restartBtn.style.cssText = 'padding: 12px 20px; background: var(--accent); color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer; min-width: 120px; flex: 1 1 auto;';
  restartBtn.textContent = 'თავიდან დაწყება';
  
  const closeBtn = document.createElement('button');
  closeBtn.id = 'closeProgressBtn';
  closeBtn.style.cssText = 'padding: 12px 20px; background: var(--danger); color: white; border: none; border-radius: 6px; font-size: 15px; font-weight: 600; cursor: pointer; min-width: 120px; flex: 1 1 auto;';
  closeBtn.textContent = 'დახურვა';
  
  buttons.appendChild(continueBtn);
  buttons.appendChild(restartBtn);
  buttons.appendChild(closeBtn);
  
  modal.appendChild(header);
  modal.appendChild(content);
  modal.appendChild(buttons);
  modalOverlay.appendChild(modal);
  
  document.body.appendChild(modalOverlay);
  
  // Event Listeners
  continueBtn.addEventListener('click', function() {
    modalOverlay.remove();
    
    // Auto-select the appropriate mode
    const modeExam = document.getElementById('modeExam');
    const modeSequential = document.getElementById('modeSequential');
    const modeShuffleQuestions = document.getElementById('modeShuffleQuestions');
    const modeShuffleAnswers = document.getElementById('modeShuffleAnswers');
    
    // Determine last mode from progress
    const lastNormalIndex = progress.normal?.currentIndex || 0;
    const lastExamIndex = progress.exam?.currentIndex || 0;
    
    if (lastExamIndex > 0) {
      // Last used exam mode
      if (modeExam) modeExam.checked = true;
      if (modeSequential) modeSequential.checked = false;
      if (modeShuffleQuestions) modeShuffleQuestions.checked = true;
      if (modeShuffleAnswers) modeShuffleAnswers.checked = true;
    } else if (lastNormalIndex > 0) {
      // Last used normal mode
      if (modeExam) modeExam.checked = false;
      if (modeSequential) modeSequential.checked = true;
    }
    
    // Pass progress to startTest
    window.savedProgress = progress;
    
    // Start test with loaded progress
    setTimeout(() => {
      if (allTestsWithTopics.length > 0) {
        startTest();
      } else {
        loadCSV();
      }
    }, 300);
    
    showNotification('პროგრესი წარმატებით ჩაიტვირთა', false);
  });
  
  restartBtn.addEventListener('click', function() {
    modalOverlay.remove();
    
    // Clear the progress only for this specific module
    if (currentUser && currentUser.username && selectedModule) {
      const users = JSON.parse(localStorage.getItem('users') || '{}');
      if (users[currentUser.username] && users[currentUser.username].progress) {
        // Reset only the selected module's progress
        users[currentUser.username].progress[selectedModule] = {
          normal: { answeredQuestions: {}, currentIndex: 0 },
          exam: { answeredQuestions: {}, currentIndex: 0 },
          wrongQuestions: []
        };
        localStorage.setItem('users', JSON.stringify(users));
        userProgress = users[currentUser.username].progress;
      }
    }
    
    showNotification('პროგრესი გასუფთავდა. დაიწყეთ თავიდან!', false);
  });
  
  closeBtn.addEventListener('click', function() {
    modalOverlay.remove();
  });
  
  // Close on overlay click
  modalOverlay.addEventListener('click', function(e) {
    if (e.target === modalOverlay) {
      modalOverlay.remove();
    }
  });
}

function showCompletionScreen() {
  const totalQuestions = sessionTests.length;
  const correctCount = sessionTests.filter(q => q.hasCorrectAnswer).length;
  const percentage = Math.round((correctCount / totalQuestions) * 100);
  
  timerElement.classList.remove('hidden');
  
  const completionHTML = `
    <div style="text-align:center; padding:40px 20px; width:100%;">
      <div style="font-size:24px; font-weight:600; color:#1e293b; margin-bottom:20px;">
        ტესტი დასრულდა! 
      </div>
      <div style="font-size:18px; color:#64748b; margin-bottom:30px;">
        თქვენ დაწერეთ ${totalQuestions} კითხვიდან ${correctCount} სწორად (${percentage}%)
      </div>
      <button id="restartBtn" style="padding:14px 40px; background:var(--accent); color:white; border:none; border-radius:8px; font-size:16px; font-weight:600; cursor:pointer; transition:transform 0.2s, box-shadow 0.2s;">
        თავიდან დაწყება
      </button>
    </div>
  `;
  
  const questionContainer = document.querySelector('.question-container');
  if (questionContainer) {
    questionContainer.innerHTML = completionHTML;
  }
  examRightPanel.classList.add('hidden');
  questionCounter.classList.add('hidden');
  
  document.getElementById('restartBtn')?.addEventListener('click', () => {
    location.reload();
  });
}

// ==================== START BUTTON EVENT LISTENER ====================
startBtn.addEventListener('click', function() {
  console.log("Start button clicked");
  
  if (!allTests || allTests.length === 0) { 
    showNotification('ტესტები ჯერ არ არის ჩატვირთული');
    return; 
  }
  
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (!testTypeSelect || testTypeSelect.value === '') {
    showNotification('გთხოვთ აირჩიოთ მოდული');
    return;
  }
  
  currentTestType = testTypeSelect.value;
  console.log("Test type set to:", currentTestType);
  
  if (currentTestType === 'rezidentura') {
    const topicsSelect = document.getElementById('topicsSelect');
    if (topicsSelect && (!topicsSelect.value || topicsSelect.value === '')) {
      showNotification('გთხოვთ აირჩიოთ თემა!');
      return;
    }
  }
  
  startTest();
});

// ==================== DOM CONTENT LOADED ====================
window.addEventListener('DOMContentLoaded', () => {
  console.log("DOM loaded, initializing app...");
  
  // Initialize chat elements
  chatButton = document.getElementById('chatButton');
  chatWindow = document.getElementById('chatWindow');
  closeChat = document.querySelector('.close-chat');
  chatMessagesEl = document.getElementById('chatMessages');
  onlineCount = document.getElementById('onlineCount');
  chatInput = document.getElementById('chatInput');
  sendBtn = document.getElementById('sendBtn');
  
  // Initialize navigation buttons
  prevBtn = document.getElementById('prevBtn');
  nextBtn = document.getElementById('nextBtn');
  autoBtn = document.getElementById('autoBtn');
  
  examPrevBtn = document.getElementById('examPrevBtn');
  examNextBtn = document.getElementById('examNextBtn');
  examAutoBtn = document.getElementById('examAutoBtn');
  examFinishBtn = document.getElementById('examFinishBtn');
  
  detailedResultsModal = document.getElementById('detailedResultsModal');
  detailedResultsContent = document.getElementById('detailedResultsContent');
  
  // Initialize auth
  initAuth();
  
  // Bind events
  bindNavigationEvents();
  bindQuestionCounterEvent();
  bindTestTypeEvents();
  
  // Add test type change listener
  const testTypeSelect = document.getElementById('testTypeSelect');
  if (testTypeSelect) {
    testTypeSelect.addEventListener('change', function() {
      currentTestType = this.value;
      console.log("Test type changed to:", currentTestType);
    });
  }
  
  document.addEventListener('click', (e) => {
    if (isEditingQuestionNumber && currentQuestionEl && !currentQuestionEl.contains(e.target)) {
      isEditingQuestionNumber = false;
      renderCurrentQuestion();
    }
  });
  
  setInterval(updateTimer, 1000);
  updateTimer();
  
  window.addEventListener('beforeunload', () => {
    if (currentUser && !currentUser.isGuest && currentTestType) {
      saveUserProgress();
    }
  });
  
  if (modeSequential) {
    modeSequential.addEventListener('change', () => {
      if (modeSequential.checked && modeShuffleQuestions.checked) {
        showNotification('ეს რეჟიმები ერთად შეუძლებელია არსებობდეს!');
        modeSequential.checked = false;
      }
    });
  }
  
  if (modeShuffleQuestions) {
    modeShuffleQuestions.addEventListener('change', () => {
      if (modeShuffleQuestions.checked && modeSequential.checked) {
        showNotification('ეს რეჟიმები ერთად შეუძლებელია არსებობდეს!');
        modeShuffleQuestions.checked = false;
      }
    });
  }
  
  if (modeExam) {
    modeExam.addEventListener('change', function() {
      if (this.checked) {
        if (modeSequential) modeSequential.checked = false;
        if (modeShuffleQuestions) modeShuffleQuestions.checked = true;
        if (modeShuffleAnswers) modeShuffleAnswers.checked = true;
        
        // თუ გამოცდის რეჟიმი ჩაირთო, გავასუფთავოთ პროგრესის შემოწმების ფლაგი
        // რომ მომდევნო ჩატვირთვისას ისევ შევამოწმოთ
        window._progressCheckPerformed = false;
      }
    });
  }
  
  setTimeout(() => {
    toggleTopicsDropdown();
  }, 100);
  
  // Expose functions to global scope for onclick handlers
  window.closeSettingsPage = closeSettingsPage;
  window.enableUsernameEdit = enableUsernameEdit;
  window.togglePasswordVisibility = togglePasswordVisibility;
  window.showPasswordChangeFromSettings = showPasswordChangeFromSettings;
  window.printMistakes = printMistakes;
  window.showPasswordChangeModal = showPasswordChangeModal;

});
